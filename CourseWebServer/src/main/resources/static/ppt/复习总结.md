# 软件体系结构

## Architecture and Architect

Architectural styles 宏观

Design patterns 微观

“架构是一个系统的基本组织，体现在其组件、它们之间的关系和环境，以及控制其设计和发展的原则。”

### Architecture Defines Structure  

架构定义：

- 组件接口

  组件可以做什么

- 组件通信和依赖

  组件如何沟通

- 组件的责任

  一个组件将做什么

### Software Engineering Difficulties  

1. 有些问题是可以消除的 --> “意外困难”
2. 其他问题可以减轻，但不能完全消除 --> “基本困难”
   - 复杂性 Complexity  -- 复杂性与规模呈超线性增长
   - 一致性 Conformity
   - 可变性 Changeability  -- 软件被认为具有无限的可塑性
   - 无形性 Intangibility  -- 软件不是实体

### Software Product Line

DSSA 领域特定的架构   重要概念：可重用

重用结构、行为和组件实现对于成功的业务实践越来越重要

- 简化了软件开发任务
- 减少了开发时间和成本
- 提高了整个系统的可靠性

### The Architect's Role

- 可视化系统的行为
- 创建系统蓝图
- 定义系统各要素协同工作的方式
- 区分功能性和非功能性系统需求
- 负责将非功能性需求集成到系统中

### Architecture and Design

- 关键的区别在于细节的层次
- 架构在高层次的抽象上运行
- 设计在较低的抽象级别上运行

------

## Architectures in Context

| System Quality         | Definition                                               |
| ---------------------- | -------------------------------------------------------- |
| 可用性 Availability    | 与性能测试有关，满足定义的指标才算可用                   |
| 容量 Capacity          | 并发能力                                                 |
| 可扩展性 Extensibility | 关注点：非常经济地修改和增加功能                         |
| 灵活性 Flexibility     | 反映架构的灵活性，可升级性                               |
| 管理性 Manageability   | 管理系统以确保系统相对于其他系统质量的持续健康运行的能力 |
| 性能 Performance       | 快速执行功能以满足性能目标的能力                         |
| 可靠性 Reliability     | 确保完整性和一致性                                       |
| 可伸缩性 Scalability   | 当系统负载增加时仍旧能提供较好的服务质量                 |
| 安全性 Security        | 确保信息不被修改或泄露的能力，除非按照安全策略           |
| 测试性 Testability     | 确定预期结果的能力                                       |

### Availability

- 指标是时间
- 关键性应用追求可用性
- 采用冗余的方法提高可用性
- 保证服务或资源是高可访问的

### Reliability

- 指标是概率
- 确保应用程序及其所有事务的完整性和一致性的能力
- 采用冗余的方法提高可靠性

### Manageability

- 采用冗余的方法会降低管理性
- 管理系统以确保系统相对于其他系统质量的持续健康运行的能力

### Flexibility

- 快速迭代升级的能力
- 以经济有效的方式改变架构以满足新需求的能力
- 一个可用的、可靠的、可伸缩的应用程序的关键
- 可以通过应用程序代码的位置独立性进行改进
- 没有衡量灵活性的标准方法，基本的衡量标准是变化的成本

### Performance

- 个体：E2E（端到端）延迟
  总体：吞吐量
- 快速执行功能以满足性能目标的能力

### Capacity

- 并发量：单元时间内运行一定数量的工作

### Scalability

- 当负载增加时经济地支持所需服务质量的能力

- 垂直可伸缩性来自于向现有服务器添加容量(内存、cpu) 

  ![](img\屏幕截图 2021-01-09 130745.png)

- 水平可伸缩性来自于添加服务器 

  ![](img\屏幕截图 2021-01-09 130820.png)

- 可用性和可靠性是通过可伸缩性获得的

- 容量受可伸缩性的影响

### Extensibility

- 能够在不影响现有功能的情况下修改或添加功能
- 对于Extensibility而言，采用xml等配置文件优于使用annotation(注解@)配置

### Testability

- 确定预期结果的能力
- 多层体系结构为中间测试和调试提供了许多测试点
- 同步通讯可测试性强，异步通讯可测试性差
- POJO based programming 纯粹的java对象，可测试较强，component based 基于容器的（component本身不能运行）可测试性较差（测试时需要启动容器，而容器启动较慢）

### Security

- 身份、权限、完整、隐私、可审核性

### DSSA(特定领域软件架构)  

- 从过去的项目中获取并描述最佳解决方案和最佳实践
- 新应用的生产可以集中在新颖的变化点上
- 重用架构和实现的可应用部分
- 适用于产品线

------

## Basic Concepts

### Architecture Definition

- 软件系统的体系结构是一组关于系统的主要设计决策（principal design decisions）
- 软件体系结构是软件系统构建和发展的蓝图--关注结构、组件行为、组件交互以及这些如何影响系统的质量属性
- 设计决策包括正在开发的系统的每个方面

### Good Architecture

#### Process

- 体系结构与需要管理的质量属性的优先列表相关
- 使用反映甲方兴趣的视角编写文档
- 根据架构交付质量属性的好坏来评估架构
- 选择允许增量实现的架构

#### Structure

- 使用良好的模块化结构:隐藏信息、独立的关注点、不太可能更改的良好健壮的接口
- 结构取决于视角/视点:至少是静态的(捕获例如代码中的依赖)，动态的(捕获例如数据流中的依赖)，部署(捕获例如对资源的依赖)
- 使用众所周知的模式和策略(稍后见)来实现质量属性
- 不要依赖于特定版本的工具
- 产生数据的模块应该与使用数据的模块分开
- 不要期望模块(静态结构)和组件(动态结构)之间有简单的映射
- 除非必要，否则不要依赖于部署环境中的特殊功能
- 体系结构应该在组件之间使用少量的交互方式
- 应该清楚地确定资源争用问题

### Prescriptive vs. Descriptive Architecture  

#### Prescriptive

- 说明性架构捕获了在系统构建之前所做的设计决策
- 它是设想（as-conceived）或预期（as-intended）的体系结构

#### Descriptive

- 描述性架构描述了系统是如何构建的
- 它是实现（as-implemented or as-realized）的体系结构

### Architectural Degradation

#### Architectural Drift 架构漂移

- 架构漂移是将主要设计决策引入到系统的描述性架构中，不包含或隐含在说明性体系结构中，但是不违反任何说明性架构的设计决策

#### Architectural Erosion 架构侵蚀

- 架构侵蚀是将体系结构设计决策引入到系统的描述性体系结构中，但违反了系统的说明性体系结构
- 架构侵蚀:在计划的架构和实现的实际架构之间观察到的差距

#### Architectural Recovery

- 如果允许架构退化发生，那么迟早会被迫恢复系统的架构，架构恢复是从实现级工件确定软件系统架构的过程

### Software Component

- 软件组件是一个体系结构实体
- 在系统架构中封装处理的元素和数据被称为软件组件
- 封装系统功能和数据的一个子集
- 通过显式定义的接口限制访问该子集
- 显示定义了所需执行上下文的依赖关系
- 组件通常提供特定于应用程序的服务

### Software Connector 

- 软件连接器是一个架构构建块，其任务是影响和调节组件之间的交互
- 在许多软件系统中，连接器通常是简单的过程调用或共享数据访问
- 连接器通常提供与应用程序无关的交互设施--可独立于部件进行描述

### Architectural Configuration 

- 体系结构配置或拓扑，是软件系统体系结构的组件和连接器之间的一组特定关联
- 组件和连接器在给定的系统架构中以特定的方式组合，以实现系统的目标

### Architectural Style

- 体系结构风格是体系结构设计决策的命名集合
- 是适用于一个给定的开发环境
- 约束特定于该上下文中特定系统的架构设计决策
- 在每个产生的系统中引出有益的品质

### Architectural Pattern  

- 体系结构模式是一组适用于重复出现的设计问题的体系结构设计决策，并且参数化以说明问题出现时的不同软件开发上下文

### Style与Pattern区别

#### Style

- 提供一组采用解决方案的指导原则
- 需要相当大的努力来应用
- 架构师需要根据架构风格来证明设计选择

#### Pattern

- 提供具体的解决方案，尽管参数化了具体的问题
- 只需很少的人力或理由来应用
- 通常适用于特定的系统(例如，基于gui的系统)

------

## Architectural Views

### Logical View

- 逻辑体系结构主要考虑**功能需求**，系统应该为用户提供哪些服务
- 通过类图和类模板，我们可以使用UML方法来表示逻辑架构

![](img\屏幕截图 2021-01-09 152806.png)

### Process View

- 过程架构考虑了一些非功能性需求，考虑**并发和同步**，即**模块间的通信**
- 过程体系结构可以在多个抽象层次上进行描述，每个层次处理不同的关注点
- 软件被划分为一组独立的任务，任务是一个单独的控制线程，可以在一个处理节点上单独调度

![](img\屏幕截图 2021-01-09 152900.png)

#### Major Tasks

- Major tasks通过一组定义良好的**任务间通信机制**进行通信:同步和异步基于消息的通信服务、远程过程调用、事件广播等
- Major tasks不应该假设自己在同一进程或处理节点中的配置情况

#### Minor Tasks

- Minor tasks可以通过**集合点**或**共享内存**进行通信。

### Development View/Implementation View

- 开发体系结构关注软件开发环境下的**实际软件模块组织**
- 软件被打包成小块--程序库或子系统--可以由一个或少数开发人员开发
- 系统的开发架构由显示“导出”和“导入”关系的模块和子系统图表示
- 在大多数情况下，开发体系结构考虑的内在需求--重用、灵活性、可扩展性
- 开发视图作为需求分配的基础

![](img\屏幕截图 2021-01-09 153452.png)

### Deployment View/Physical View

- 描述了软件到硬件的映射，并反映了它的分布式方面
- 物理架构主要考虑了系统的非功能需求--可用性、可靠性(容错)、性能(吞吐量)和可伸缩性
- 我们期望使用几种不同的物理配置--有些用于开发和测试，其他用于为不同的站点或不同的客户部署系统

![](img\屏幕截图 2021-01-09 153723.png)

### Scenarios/Use Case View

- 这些场景在某种意义上是最重要需求的抽象--用例视图

![](img\屏幕截图 2021-01-09 153858.png)

### Conclusion

![](img\屏幕截图 2021-01-09 154658.png)

------

## Designing the Architecture  

### Attribute-Driven Design  

- 一种称为属性驱动设计(ADD)的方法可以用来设计同时满足质量和功能需求的体系结构
- ADD可以被看作是其他开发方法的扩展，例如Rational统一过程(RUP)
- ADD基于软件必须实现的质量属性的分解过程
- 它是一个迭代的分解过程，在每个阶段，策略和架构模式被选择来满足一组质量场景，然后功能被分配来实例化模式提供的模块类型
- 系统被描述为一组用于存放功能和它们之间交互的容器
- 这是实现功能的粗粒度框架

#### Input to ADD

- 一组需求(通常表示为用例)和约束
- 一组表示为特定于系统的质量场景的质量需求

#### ADD Steps

1. 选择要分解的模块——要开始分解的模块通常是整个系统

2. 按照以下步骤细化模块

   从一组具体的质量场景和功能需求中**选择架构驱动**

   根据可用于实现架构驱动的**策略**，**选择**满足架构驱动的**架构模式**

   **实例化模块并从用例中分配功能**，并使用多个视图表示 -- 模块分解视图、并发视图、部署视图

   **定义子模块的接口**。分解提供了模块和模块交互类型的约束。在每个模块的接口文档中记录这些信息

   **验证和细化用例和质量场景**，并使它们成为子模块的约束

3. 迭代：对每个需要进一步分解的模块重复上述步骤

------

## Pattern and Style I  

### Architectural Patterns

- 架构模式是一组适用于重复出现的设计问题的架构设计决策，并且参数化以说明问题出现时的不同软件开发上下文
- 架构模式与DSSAs类似，但是应用于“较低的级别”和更小的范围

### Model-View-Controller (MVC)  

- 目标:分离信息、表示和用户交互
- 当模型对象值发生变化时，一个通知被发送到视图和控制器。这样，视图可以更新自己，控制器可以修改视图，如果它的逻辑需要的话
- 当处理来自用户的输入时，窗口系统将用户事件发送给控制器;如果需要更改，控制器将更新模型对象

![](img\屏幕截图 2021-01-09 212714.png)

### Architectural Styles  

- 架构风格是架构设计决策的命名集合
- 适用于给定的开发环境
- 约束特定于该上下文中特定系统的架构设计决策
- 在每个产生的系统中引出有益的品质
- 描述软件系统设计经验教训的主要方法
- 用于确定从子例程结构到顶层应用程序结构的所有内容
- **styles比patterns反映更少的领域特性**

### Data-flow Architectures  

- 这些体系结构的目标是实现**可重用性**和**可修改性**的质量
- 数据流样式的特点是将系统视为对连续输入数据（一段一段的数据输入--可看做链表）的一系列转换
- 数据进入系统，然后流经各个组件，一次一个
- 最后，数据被分配到某个最终目的地(输出或数据存储)

- 数据流架构可以分为批处理顺序架构、管道和过滤器

- 在批处理顺序架构中，在开始下一个步骤之前，每个步骤运行到完成

- 在管道和过滤器架构中，步骤可以并发运行，以增量方式处理数据的各个部分

  > 并行：1.任务并行（pipes and filters架构，filter处理数据，处理完后通过pipe将数据传输到下个filter。filter之间存在同步问题，因为filter运行速度不同。）
  >            2.数据并行（将大量的数据分成小块，在不同的进程里采用相同的方法处理。Master-Slave程序，Master分配数据，Slave处理数据，Slave处理完数据后通知Master。该程序加速比很高）

#### The Pipe-and-Filter Architectural Pattern  

- 数据流以一种相对简单的格式通过一系列处理
- 数据持续输入管道;每个组件以某种方式转换数据
- 这些进程可以并发地工作，不断的数据输入和输出
- 非常灵活的架构，几乎所有的组件都可以移除，组件可以添加、更改、删除和重新排序
- 非常灵活，特别是(例如)在转换数据或过滤(删除)字符或特征等方面，有时(通常)数据可能会经历一系列转换...也可以分裂管道或连接管道

#### Pipe and Filter Style  

- 组件是过滤器：将输入数据流转换为输出数据流，可能增量产出

- 连接器是管道：数据流管道

- 风格不变量：过滤器是独立的(没有共享状态)，过滤器不了解上、下游过滤器

![](img\屏幕截图 2021-01-09 215723.png)

#### Pipes and filters - advantages  

- 管道在概念上是简单的(有助于维护)，组件可以重用
- 易于添加和删除组件(有助于可进化性)
- 允许注入特殊组件来解决横切问题，例如，监控吞吐量，日志记录，…
- 允许并发/并行执行(有助于可伸缩性)

#### Pipes and filters - disadvantages  

- 管道经常导致批处理
- 不适合交互式应用程序
- 很难实现增量更新
- 数据结构的最小共同特性
- 每个过滤器必须解析/打包数据(不利于性能)
- 增加每个组件的复杂性

#### Batch Sequential

- 一个降级版本的管道和过滤器风格
- 批处理模型还强调数据在过程步骤间传递，然而，数据是以块传输，数据不会转移到下一个过程步骤，直到整个块被处理。每一个过程的步骤是独立于任何其他步骤

![](img\屏幕截图 2021-01-09 220927.png)

### Data-centered Architecture  

- 这些架构的目标是**实现数据的可集成性**，重点关注**数据完整性**
- 这个术语指的是访问和更新**广泛访问的数据存储**是其主要目标的系统
- 基本上，它只不过是一个与许多客户机通信的集中式数据存储
- 对于这种样式，重要的是三种协议:**通信协议**、**数据定义协议**和**数据操作协议**

- 通信手段区分了这两种子类型：**Repository** and **Blackboard**
- **Repository**:客户端向系统发送请求以执行必要的操作(例如插入数据)
- **Blackboard**(需要Notification架构支持):当用户感兴趣的数据发生变化时，系统会向用户发送通知和数据，所以是主动的

> - 短连接：客户端与服务器传输数据（Repository）后，连接关闭，减轻服务器的压力
> - 长连接：客户端与服务器建立连接后，连接不会断开，服务器可与客户端主动通信（Blackboard），服务器压力较大。服务器不知道客户端的ip地址，只能采用长连接方法

#### Repository

![](img\屏幕截图 2021-01-09 222002.png)

#### Blackboard

![](img\屏幕截图 2021-01-09 222041.png)

- Blackboard架构传统上用于复杂系统，相对来说Blackboard架构代价较大

#### Data-centered architectures: advantages

- 确保数据的完整性
- 可靠、安全、可测试性得到保证
- 客户端独立于系统:客户端的性能和可用性通常都很好

#### Data-centered architectures: disadvantage  

- 可伸缩性、可靠性方面的问题(单点故障)
- 解决方案:共享存储库、复制，但这会增加复杂性
- 哪些功能在数据库中，哪些在客户端中，界限不清

> - **数据分片**(将数据分成不同部分存入不同的数据库)只能提高scalability和performance，但不能提高reliability，用户可以并发访问数据库，但数据只有一份，分片规则存储在Gateway，访问数据库前需访问Gateway，这可能会成为性能瓶颈
> - **数据复制**(分布式复制数据库)能提高scalability，performance和reliability，但会引起数据一致性问题

#### Web architecture  

- 以数据为中心的架构的另一个例子是Web架构
- 超媒体数据模型后面有一个通用的数据模式(即Web的元结构)
- 页面(节点)和节点之间的链接，以及寻址机制
- 数据操作不是直接在系统中进行的，通常是通过应用程序实现的
- 尽管HTTP协议有数据操作的方法
- 分析:不保证完整性(404错误)，但非常scalability

#### Resource-Oriented Architecture  

- 这样的架构将Web看作是一个巨大的分布式数据库
- 数据模型:节点可通过URL寻址并相互链接
- 数据操作:HTTP方法(GET, PUT, POST，DELETE)
- 可扩展性、良好的性能、可用性等

### Layered Architectures  

- 具有明确职责层的架构
- 层向下通信（自顶向下），通常紧接下面，很少有“跳跃”
- 较高层将较低层视为一组服务
- 通常，一个层只与它下面的层通信，不总是这样，但通常是这样

- 分层:系统的结构被组织成一组层，每一层位于另一层的顶部
- 层之间定义良好的接口
- 降低复杂性，提高模块化，可重用性，可维护性，分层的不同标准:最明显的是抽象

#### Layered Style  

- 层次系统组织：“多层次的客户端-服务器”，每一层都公开一个供上面各层使用的接口(API)
- 每一层充当：服务器:“上”层的服务提供商；客户端:“下”层的服务消费者
- 连接器是层交互的协议

#### Multi-Layered Architectural Pattern  

- 在不断增加的抽象级别上使用层构建
- 用户界面层——通常首先用于展示、交互
- 应用层通常紧接在UI层之下，通常提供由应用程序用例确定的应用程序功能。(应用层)
- 域层通常是下一层，它提供一般的域级服务(业务用例)
- 服务/支持(底层)层提供一般的(但基本的)服务。例如，网络通信、数据库访问，操作系统服务

![](img\屏幕截图 2021-01-09 224933.png)

#### Layered architecture - advantages  

- 每一层只与邻层耦合
- 有助于可进化性，因为可以交换单个层并限制对邻层的修改
- 有助于可重用性，因为层可以被多个系统使用，特别是如果通信是标准化的
- 在实践中，每一层通常由专门的开发团队维护

#### Layered architecture - disadvantages  

- 并不是所有的系统都适合分层组织
- 抽象可能会对性能产生负面影响，例如，不可能找到特定的优化，很难找到正确的抽象级别
- 在实践中，我们付出了很多努力来实现那些影响多层的特性

#### 2-tier architectures  

- 客户端通常很丰富，Rich Client(ui+applogic+communication)

  > Rich Client包含应用程序的全部知识
  > ·它可以访问平台上的全套UI机制
  > ·两种富客户端
  >   -使用标准协议的标准应用程序的客户端(例如，电子邮件客户端)
  >   -使用自定义协议的自定义应用程序的客户端
  >
  > Thin Client对应用知之甚少
  > ·完整的应用知识在服务器上
  > ·最明显的是:网络客户端
  > ·即使使用AJAX:它是由服务器提供的，即应用程序知识在服务器上
  >
  > 另一种形式:图形化Thin Client
  > ·仅显示图形用户界面
  > ·在这种架构中，我们有一个所谓的显示服务器
  > ·它驻留在服务器端，但作为用户界面屏幕
  > ·它将用户屏幕中的变化传递给客户端

- 服务器存储数据

- 每个客户机运行一个完整的应用程序

- 缺点:每个客户机必须知道如何与所有数据服务器通信

- 由于客户端与服务器紧密耦合，可伸缩性受到影响

  ![](img\屏幕截图 2021-01-09 230304.png)

#### 3-tier architectures  

- 从2层架构演变而来，以解决其缺点
- 在客户端和数据服务器之间插入第三层，应用程序或业务逻辑层:中间层
- 中间层通常位于服务器端(但最近可能在服务器和客户端之间分离)
- 另一些优势：
  -更容易维护客户端，因为中间层可以独立更新
  -更好的隔离数据存储的细节:可扩展性，可配置性
  -更佳的网络使用
  -在中间层添加额外处理层的可能性
  -干净地分离表示，应用逻辑和数据存储

![](img\屏幕截图 2021-01-09 230343.png)

### Notification Architectures 

- 松散耦合组件的架构
- 通过通知机制传播信息和活动的体系结构
- 存在在设计时还不知道的复杂通信模式
- 基本上，感兴趣的组件会注册它们感兴趣的事件，当事件发生时，感兴趣的组件会得到通知
- 也称为:发布-订阅，其他术语:监听和回调，类似于设计模式领域的观察者模式，类似于blackboard数据中心架构
- 通知体系结构更为通用，因为任何类型的事件都可能发生，而不仅仅是与数据相关的事件

在执行级别有两个变体：

1. 对事件感兴趣的组件直接注册到生成这些事件的进程

2. 组件注册到专用通知组件

- 这两个变体中的通信样式都是回调

额外的变体：

- 当事件发生时，通知组件可以将事件发送到所有注册的组件(广播)
- 另一种可能是只将事件发送给感兴趣的组件
- 通知可能包含所有相关数据(推送风格)
- 通知只是表示发生了什么事情:注册的组件提取相关数据

![](img\屏幕截图 2021-01-09 232306.png)

#### Event-Based Style  

- 通过事件总线通信，独立组件异步发送和接收事件
- 组件:独立的、并发的事件生成器和/或使用者
- 连接器:事件总线(至少一个)
- 数据元素:事件——作为头等实体通过事件总线发送的数据
- 拓扑:组件与事件总线通信，而不是直接彼此通信
- 变体:组件与事件总线的通信可以是基于推或基于拉的
- 高度可伸缩，易于发展，对高度分布式应用程序有效

> SOA：把系统按照实际业务，拆分成刚刚好大小的、合适的、独立部署的模块，每个模块之间相互独立
>
> 缺点：容易形成网状结构，不好管理（引入数据总线，系统便于管理）

![](img\屏幕截图 2021-01-09 232647.png)

#### Notification architectures - advantages  

- 松散耦合
- 可以很容易地更改和添加通知接收者
- 有助于evolvability

#### Notification architectures - disadvantages  

- 无法控制进程流
- 由于异步特性，可能不是确定性的(不利于可测试性)
- 不清楚应随通知传递哪些数据，如果传递的数据太少，接收方可能需要获取它(增加耦合)
- 性能问题由于更新风暴甚至更糟，可能会有无尽的循环

------

## Pattern and Style II  

### Network-Centered Style  

- 至少有一个组件具有服务器角色:等待并处理连接
- 至少有一个具有客户端角色的组件，启动连接以获取某些服务

#### Client-Server Style 

- 组件是客户端和服务器

  客户端使用服务，服务器提供服务，服务可以是任何资源

- 服务器不知道客户端的数量或身份

- 客户端知道服务器的身份

- 连接器是基于RPC的网络交互协议

#### Client-Server  

- 两种基本类型的服务器拓扑：集中的服务器，或者分布式服务器
- 集中式服务器更容易管理(安装、部署、更新、维护、监控...)
- 分布式服务器伸缩性更好，但可能会引入复杂性(例如，需要两阶段提交)

##### Stateful vs. stateless  

- 如果客户机-服务器通信是**有状态**的，**服务器**将跟踪应用程序的状态，通常提供句柄或会话id，然后客户端可以操作服务器上的状态。对客户端来说更容易，因为他们不需要管理状态==>如果与瘦客户机耦合，则需要。
- 如果客户机-服务器通信是**无状态**的，则**客户机**负责跟踪应用程序的状态，服务器不需要存储或管理特定于会话的数据，通常与富客户端耦合，因此，无状态服务器的可伸缩性通常比有状态服务器好。

> - 无状态：pool容器管理多个instance（整个生命周期），客户端有请求就分配一个instance提供服务，服务提供完就释放instance，如果instance分配完客户端需要排队等待
> - 有状态：客户端与instance绑定（有100个客户就需要100个instance），服务提供完并不会释放instance，instance生命周期由客户管理

#### Client-Server -Scalability  

- 扩展的两种基本类型：

- 垂直地，通过增加单机的计算能力，向上扩展（比较难）

  垂直扩展通常是唯一的选择，特别是当系统还没有被从头设计成允许分布式处理时。在虚拟环境(虚拟机而不是物理环境)中，垂直扩展变得更加容易，因为这个系统可以在系统不知情的情况下被转移到一个更强大的机器上。

- 水平地，通过添加更多的机器(水平扩展)

  水平扩展为可伸缩性提供一个较高的上限。需要系统的支持，不是每个系统都允许分布式，可能会由于节点之间的同步而导致较高的通信开销。分布式服务器需要专门设计以允许水平伸缩，通常会花费更多的精力去开发，升级到更大的机器可能更便宜。

- 哪一种策略(向上扩展还是水平扩展)更适合，这取决于实际的系统

#### Client-Server -Advantages  

- 概念上很简单
- 清晰的职责分离，简化了evolvability，有助于测试性
- 良好的可伸缩性(特别是在无状态时)，优秀的可伸缩性(如果服务器可以扩展)
- 有利于安全性，因为数据可以在访问受限的情况下保存在服务器上

#### Client-Server -Disadvantages  

- 如果客户端和服务器之间的通信很慢，或者有很高的延迟，那么存在可用性和性能差的风险
- 需要在客户端和服务器端之间开发/达成协议
- 对于有状态的集中服务器，可伸缩性是有限的
- 可集成到现有系统中可能是不可能的(例如，如果不可能或不允许通信)

#### Peer-to-Peer Style  

- 状态和行为分布在可以充当客户机或服务器的对等点之间
- 对等方:独立的组件，有自己的状态和控制线程
- 连接器:网络协议，通常是定制的
- 数据元素:网络消息

#### Peer to Peer  

- 客户机和服务器之间的分离被删除，每个客户机同时是一个服务器，称为对等点
- 目标是将处理或数据分布在许多对等点上，没有中央管理或协调
- 每个对等点提供服务并使用服务
- 通信可能发生在所有对等点之间
- 对等点的数量是动态的
- 每个对等点必须知道如何访问其他对等点(发现、搜索、加入)
- 一旦对等点被初始化，它就需要成为网络的一部分
- 需要一个自举机制：例如通过广播消息，网络地址的公开列表

#### Peer to peer -centralised P2P  

- 有些方面是集中的，例如，中心组件跟踪可用的对等点

#### Peer to peer -hybrid P2P  

- 不是所有的对等点都是平等的，有些有额外的责任，它们被称为超级节点
- 例如:Skype使用点对点协议，但也使用超级节点和中央登录服务器

#### Peer to peer -Advantages  

- 通常具有优秀的可伸缩性，因为计算可以分布式进行
- 很好的可靠性，因为数据可以在多个对等点上复制，无单点故障

#### Peer to peer - Disadvantages  

- 服务质量是不确定的，不能保证，例如高延迟
- 非常复杂，难以维护和测试

### Remote Invocation Architectures 

#### Remote invocation and service architectures  

- 远程调用体系结构涉及分布式处理组件
- 通常，客户端组件调用远程组件上的方法(函数)

> socket: service端listen某个端口port，client使用open方法建立连接，client使用send方法向service请求数据，使用receive方法接受数据
>
> RPC家族：CORBA分布式中间件
>                     DCOM-- .net
>                     RMI-- JavaEE
>                     Web Service

- 优点:通过分布式计算提高性能，只有当网络是可靠的和快速的，并且通信开销是可管理的
- 缺点:通常是组件的紧密耦合，对可寻址性(回收对象的唯一标识)的管理增加了通信开销

- 服务体系结构引入了注册服务的特殊组件
- 任何对服务感兴趣的组件都会向该组件询问服务的地址
- 它试图解决可寻址性问题
- 如果通信协议是标准化的，那么服务就可以即时集成

- 使用Web协议进行通信
- 但是，由于您必须知道如何在远程服务中寻址对象，因此仍然没有对寻址能力进行管理
- Web服务本质上只是使用Web协议的远程过程调用
- 优点和缺点是一样的

#### Broker

- 代理：希望某种透明性时，采用代理技术（透明性：用户不知道下层的实现细节）
- 将通信与应用程序功能分离，对分布式系统的支持
- 代理对系统的组件隐藏通信，代理协调通信
- 代理可用于透明地将非分布式系统更改为分布式系统，例如:客户端通过代理与远程对象交互
- 注:类似于proxy设计模式

#### The Broker Architectural Pattern  

- 在这里，我们透明地将软件系统的各个方面分发给不同的节点
- 对象调用方法的其他对象，而不知道其他对象位于远程
- 客户端不“关心”远程对象在哪里
- 可以使用“proxy设计模式”，让proxy对象调用broker，broker决定所需对象的位置

![](img\屏幕截图 2021-01-10 092446.png)

#### Broker -Tasks of a broker  

找到合适的服务器/服务，将请求转发给服务器，将结果(或错误消息/异常)报告给客户端

通信从客户端抽象出来

#### Broker -Advantages  

- 组件的解耦(网络方面)有助于灵活性、可维护性和可进化性
- 允许一个系统成为分布式，即使它一开始并没有为此设计

#### Broker -Disadvantages  

- 网络通信可能会引入新的错误类型
- 由于网络延迟和有限的带宽，行为可能会改变

### Interpreter Style  

- 解释器：输入根据不同的用户解释成不同的东西
- 围绕一个核心Simulated interpretation engine，类似于rule-based的系统

![](img\屏幕截图 2021-01-10 093222.png)

- 体系结构是基于虚拟机在软件中产生的
- 一种特殊的分层架构，其中一个层被实现为一个真正的语言解释器
- 组件：正在执行的“程序”及其数据，解释引擎及其状态

> 适合小系统，单机运行

- 解释器解析并执行输入命令，更新解释器维护的状态
- 组件:命令解释器，程序/解释器状态，用户界面
- 连接器:通常与直接过程调用和共享状态紧密绑定
- 高度动态行为，其中命令集是动态修改的
- 当基于现有原语创建新功能时，系统架构可能保持不变
- 极佳的终端用户可编程性;支持动态更改功能集

#### Interceptor -Overview 

- 拦截器：主要实现单一原则，有容器作为支撑可以实现拦截
- 动机:将功能分离为单独的组件
- 允许在不更改核心组件的情况下集成其他服务
- 组件提供的接口，允许另一个组件注册自己，并在特定事件中调用
- 开闭设计原则(对扩展开放，对修改关闭)
- 用于处理横切关注点

#### Interceptor -Example  

- 例如:日志记录
- 系统由两个组件组成:客户端和服务器
- 当某些事件发生时，每个组件提供一个回调接口
- 日志组件在每个组件上注册自己
- 日志组件将日志存储到共享存储库中

#### Interceptor -Advantages  

- 拦截器组件可以重用(可重用性)
- 优秀的灵活性
- 明确的关注点分离，松耦合->可维护性，可进化性

#### Interceptor -disadvantages  

- 能很快变得相当复杂
- 潜在的级联回调，无尽的循环
- 有时事件不确定
- 核心组件需要提供回调接口
- 可能导致不良的可测试性

### GUI Architectures  

#### Model View Controller (MVC)  

- 动机:可重用性和关注点分离，三种角色:模型、视图和控制器

- **模型**:封装应用程序域的行为和数据

  封装应用程序状态，对状态查询的响应，暴露应用程序功能，通知变更视图(可选)，注意:只有当模型和视图实现了观察者模式时，才需要通知

- **视图**:呈现模型

  展示模型，从模型请求更新，为控制器准备用户界面，通常多个视图

- **控制器**:对用户输入作出反应，修改模型并分派给视图

  操纵模型，触发应用程序行为，选择响应视图(可选)

- 控制器和视图都依赖于模型，控制器和视图是UI的一部分

- 模型-视图-控制器模式不会取代n层体系结构

- 模型与较低的抽象层进行通信(例如数据访问层)

- 模型可能使用通知模式来通知视图更改

- 较少为人所知的表示-抽象-控制模式类似于MVC

![](img\屏幕截图 2021-01-10 094808.png)

#### MVC -Advantages  

- 关注点分离，有助于重用性(controller最容易重用,view也可重用，model不能重用)
- 多用户界面，而不改变模型，如移动和网络
- 有助于可配置性(因为界面更改更容易，与应用程序逻辑更改相比，预期的副作用更少)

#### MVC -Disadvantages  

- 附加组件增加复杂性，并不是所有系统都适用于MVC模式
- 如果对视图的更新是基于通知的，那么可能很难找到错误
- 在这些情况下，很难确保良好的usability(当更新发生时没有控制)

#### Presentation--Abstraction--Control  

- 一种面向交互的软件架构，在某种程度上类似于模型-视图-控制器(MVC)，因为它将一个交互系统分割成三种类型的组件，负责应用程序功能的特定方面
- **抽象**组件检索和处理数据
- **表示**组件对数据的可视和音频表示进行格式化
- **控制**组件处理其他两个组件之间的低控制和通信等事情

#### Difference between MVC and PAC  

- MVC的控制器关注于视图的输入和输出
- 而PAC的控制器主要负责代理之间和代理内部的通信和协调

- PAC将系统划分为分层的和松散耦合的代理
- 而MVC侧重于模型和视图的分离，其中没有分层的代理

### Adaptive Styles

#### Micro Kernel  

- 微内核是能够启动一个软件系统所需服务的软件的最小数量

#### Reflection  

- 有关于系统其他元素的元信息
- 元信息用作与其他元素通信的基本元素
- 元信息描述的元素是基本元素
- 基本元素有许多公共属性，uniOied流程将应用于这些属性

> - 底层由java反射机制实现
> - Class a = Class.forName("具体类名")，该类名以key-value对的形式保存在Descriptor（配置文件）中，修改配置文件比较方便

![](img\屏幕截图 2021-01-10 100316.png)

##### Reflection  Advantage  

- 添加新元素或属性非常容易
- 支持各种修改

##### Reflection  Disadvantage  

- 低性能
- 类的复杂结构

### Transaction-Processing  

#### Transaction-Processing Architectural Pattern  

- 一个进程一个接一个地读取一系列输入，每个输入描述一个事务--一个通常(例如)可能更改系统存储的某些数据的命令

- 通常情况下，事务是一个接一个出现的，通常是原子的。做这个，再做那个，再做另一件事。添加、更改、删除...

- 事务分配器（transaction dispatcher）简单地处理事务，并将该事务“交给”特定的事务处理程序（transaction handler），该事务处理程序专门用于“处理”此类事务

- 事务处理程序（transaction handler）是专门为处理特定类型的事务而设计和实现的

  ![](img\屏幕截图 2021-01-10 101343.png)

#### Transaction Dispatchers – Some Complexity  

- 在线程环境中，许多事务可能在“进程中”，要修改的数据必须适当地锁定和释放。增加复杂性
- 当应用程序需要在更新事务之前执行查询，同时确保数据不被更改时，情况尤其复杂

### Implicit Invocation Style  

- 隐式调用是事件驱动的,基于广播的概念(广播)
- 而不是直接调用一个过程,一个组件通知一个或多个事件发生了
- 需要注册过程
- 这种类型的系统中的数据交换必须通过存储库中的共享数据来完成
- 事件声明，而不是方法调用：“侦听器”注册感兴趣的方法并将其与事件关联起来，系统隐式调用所有注册的方法
- 组件接口是方法和事件
- 两种连接器：响应事件的调用是显式的或隐式的
- 风格不变性：“广播员”不知道事件的影响，对于响应事件的处理没有任何假设

#### Advantages  

- 容易重用来自其他系统的组件
- 对用户界面特别有用

#### Disadvantages

- 事件的响应是不确定的
- 很难测试系统的所有可能的事件序列

### Process control  

- 系统被划分为多个独立的进程
- 进程之间同步或异步通信
- 通信连接决定系统的拓扑性质
- 进程控制系统与基于功能或对象的设计非常不同
- 进程控制系统的特征不仅在于部件的类型，而且在于它们之间的关系，例如：核动力系统中对核燃料棒中原子分裂状态的控制  ，空调系统的温度控制  
- 最常见的基于软件的控制系统包括两种形式之一的闭环，反馈和前馈

#### Advantage  

> 有标准的控制流时

- 问题的分解是直接的
- 系统的演进和集成容易
- 可以通过并行来提高性能

#### Disadvantage  

> 对通信的实时性要求较高时

- 通信的时间是难以控制的
- 进程之间的通信成本相当高

### Rule-based Architecture

- 将人类专家的知识编码为规则，当指定的条件满足时，规则被执行或激活
- 对输入进行解析，根据规则确定系统状态，类似于之前的解释器架构

![](img\屏幕截图 2021-01-10 103358.png)

#### Rule-Based Style  

- 推理引擎解析用户输入并确定它是事实/规则还是查询。如果它是一个事实/规则，它将该条目添加到知识库中。否则，它将查询知识库中的适用规则，并尝试解析查询
- 组件:用户界面，推理引擎，知识库
- 连接器:组件通过直接的过程调用和/或共享内存紧密地相互连接
- 数据元素:事实和查询
- 通过从知识库中添加或删除规则，可以非常容易地修改应用程序的行为
- 注意:当涉及大量规则时，理解受相同事实影响的多个规则之间的交互将变得非常困难

### Heterogeneous architectures  

- 没有一个真正的系统严格遵循单一的风格
- 风格本身并不是严格分离的，但它们是模糊的。架构在概念上可能是异构的
- n层架构是分层架构，n层体系结构通常是以数据为中心的体系结构
- 瘦客户机涉及某种通知体系结构
- 架构在结构上可能是异构的，总体架构遵循一种风格
- 单个组件遵循其他样式
- 例如，Web有两层架构:浏览器和服务器，浏览器本身有一个处理用户事件的通知体系结构
- 执行级别的架构可能是异构的，执行级别的组件遵循不同的风格
- 例如，如果组件是分布式的，通知架构可能包括远程过程调用，服务架构需要网络架构，网络架构是分层的架构，等等
- 在实际系统中，架构在所有层次上都是异构的

基于网络的搜索引擎
•概念上:以数据为中心，分层，三层
•结构上:分层(网络)，三层，通知
•执行:分布式、面向服务、带有回调的通知...

#### Patterns’ Impact on Usability, Security, Maintainability and Efficiency  

![](img\屏幕截图 2021-01-10 104544.png)

#### Patterns’ Impact on Reliability, Portability, and Implementability  

![](img\屏幕截图 2021-01-10 104625.png)

------

## Service Architectures  

### Component-based development （CBD）

- CBD主要目的：解放程序员，实现可重用

- component的运行依赖容器，利用CBD开发时，需要实现component和contract（配置文件），容器管理component的生命周期，system service（例如安全、并发等）由容器管理，程序员只需关注业务逻辑

- #### Component Categories and Abstraction  

- 软件组件为软件构件的重用提供了载体，因此可以在软件生命周期的所有级别上使用:分析、设计、实现和部署
- 概念性组件:组件分析和设计水平
- 实现组件:开发工作产品组件，如源代码文件、数据文件等
- 部署组件:参与一个可执行的系统,如动态库和可执行文件

#### Components may also exist at different levels of abstraction  

- 函数抽象:组件实现单个函数，如数学函数。提供接口就是函数。
- 随意分组:组件是一组松散相关的实体，可能是数据声明、函数等。
- 数据抽象:组件在面向对象语言中表示数据抽象或类;provides接口由创建、修改和访问数据的操作组成。
- 集群抽象:组件是一组一起工作的相关类(称为框架);provides接口是所涉及对象的提供接口的组合。
- 系统抽象:组件是一个完整的自包含系统(也称为COTS产品);provides接口是一个API，定义为允许程序访问系统命令和操作

### Resource Oriented Architectures  

ROA定义的4个特征：

- **可寻址性**:范围信息保存在URL中

  资源通过url公开——一个应用程序公开许多url

- **统一接口**:方法信息保存在HTTP方法中

  标准化的HTTP方法:CRUD操作(创建，检索，更新和删除)

  两个原则：安全性:GET只读取数据，幂等性:相同的操作无论应用一次或多次都有相同的效果

- **无状态**:每个HTTP请求都与其他请求隔离

  每个请求都包含所有必要的信息，服务器端没有管理状态。事实上，有两种状态，您应该区分应用程序状态和资源状态，应用程序状态存在于客户端，资源状态存在于服务器上。使用搜索引擎时，当前查询和当前页面属于应用程序状态，它们对每个客户来说都是不同的。资源状态对于每个客户端是相同的，即搜索索引爬虫可以更新搜索索引

- **连通性**:你将资源连接到资源网络中

  资源的表示形式，例如HTML或XML，可能有到其他资源的链接。ROA服务的公理:超媒体作为应用状态的引擎。当前应用程序状态不是作为资源状态存储在服务器上，它被客户端作为应用程序状态跟踪，并由客户端通过Web的路径创建

#### REST

- REST(具象状态传输)没有严格的类型
- 通常XML作为数据格式
- 概念(RESTful)描述约束:客户-服务器、无状态、可缓存、分层系统、代码随需应变、一致性
- 如今，REST经常被用作相关架构的伞形术语

------

## Service Oriented Architecture  

### Overview of SOA  

> - SOA主要实现灵活的组织，响应需求
>
> - ROA将数据当做资源，提供给其他程序远程调用

- 面向服务架构。它是一个组件模型，它将应用程序的不同功能单元(称为服务)通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种这样的系统中的服务可以以一种统一和通用的方式进行交互。

  ![](img\屏幕截图 2021-01-10 220413.png)

- 面向服务的体系结构(SOA)是一种体系结构风格，它将业务功能表示为与实现无关的、基于标准的共享服务

- SOA是一种设计、部署和管理应用程序和软件基础设施的方法，其中:
  ——所有软件被组织成网络可访问和可执行的业务服务。
  ——服务接口采用公共标准，实现互操作性。

- SOA的一些特征是:

  使用共享服务,不需要“重新发明轮子”

  松散耦合,能在对调用应用程序的服务影响最小的情况下更新应用程序

  位置透明性,re-host应用程序对调用它们的服务的影响最小

  基于开放标准,减少对特定供应商解决方案的依赖

- SOA使企业能够避免使用应用程序之间的点到点连接的成本高昂的集成场景

  ![](img\屏幕截图 2021-01-10 173300.png)

- SOA通过公开可跨多个流程共享的共享服务来支持业务流程管理(BPM)

  ![](img\屏幕截图 2021-01-10 173339.png)

#### Key Characteristics of SOA  

- 指定了服务质量、安全性和性能。
- 软件基础设施负责管理。
- 服务被编目和发现。
- 数据被编目和发现。
- 协议仅使用行业标准



------

## Microservice Architecture  

![](img\屏幕截图 2021-01-10 171011.png)

> 云计算隔离性最好，第1层是硬件，第2层时虚拟机（虚拟机上可有多个操作系统），第3层是操作系统，第4层是应用，将操作系统和应用打包成磁盘映像就可部署，应用的崩溃不会影响另一个操作系统中的应用
>
> 数据表之间的关联比较多的不适合微服务架构

 微服务架构的每个组件都作为⼀个独⽴单元进⾏部署，让每个单元可以通过有效、简化的传输管道进⾏通信，同时它还有很强的扩展性，应⽤和组件之间⾼度解耦，使得部署更为简单。  

微服务架构模式的另⼀个关键概念是它是⼀个分布式的架构，这意味着架构内部的所有组件之间是完全解耦的，并通过某种远程访问协议（如， JMS, AMQP, REST, SOAP, RMI等）进⾏访问。这种架构的分布式特性是它实现⼀些优越的可扩展性和部署特性的关键所在。  

微服务架构另⼀个令⼈兴奋的特性是它是由其他常⻅架构模式存在的问题演化来的，⽽不是作为⼀个解决⽅案被创造出来等待问题出现。微服务架构的演化有两个主要来源：使⽤分层架构模式的单体应⽤和使⽤⾯向服务架构的分布式应⽤。  

由单体应⽤( ⼀个应⽤就是⼀个整体 )到微服务的发展过程主要是由持续交付开发促成的。从开发到⽣产的持续部署管道概念,简化了应⽤程序的部署。单体应⽤通常是由紧耦合的组件组成，这些组件同时⼜是另⼀个单⼀可部署单元的⼀部分，这使得它繁琐，难以改变、测试和部署应⽤。这些因素通常会导致应⽤变得脆弱以⾄于每次有⼀点新功能部署后应⽤就不能运⾏。微服务架构模式通过将应⽤分隔成多个可部署的单元（服务组件）的⽅法来解决这⼀问题，这些服务组件可以独⽴于其他服务组件进⾏单独开发、测试和部署 。

另⼀个导致微服务架构模式产⽣的演化过程是由⾯向服务架构模式（SOA）应⽤程序存在的问题引起的。虽然SOA模式⾮常强⼤，提供了⽆与伦⽐的抽象级别、异构连接、服务编排，并保证通过IT能⼒调整业务目标，但它仍然是复杂的,昂贵的,普遍存在，它很难理解和实现，对⼤多数应⽤程序来说过犹不及。微服务架构通过简化服务概念，消除编排需求、简化服务组件连接和访问来解决复杂度问题。  

基于REST的API拓扑适⽤于网站，通过某些API对外提供⼩型的、⾃包含的服务。这种拓扑结构由粒度⾮常细的服务组件（因此得名微服务）组成，这些服务组件包含⼀个或两个模块并独⽴于其他服务来执⾏特定业务功能。在这种拓扑结构中,这些细粒度的服务组件通常被REST-based的接⼝访问，⽽这个接⼝是通过⼀个单独部署的web API层实现的。此种拓扑的例⼦包含⼀些常⻅的专⽤的、基于云的RESTful web service，⼤型网站像Yahoo, Google, and Amazon都在使⽤。  

![](img\屏幕截图 2021-01-10 181645.png)

------

## Serverless Architecture  

- 一个用于短期运行、无状态计算和事件驱动应用程序的本地云平台，可以即时自动地伸缩，并以毫秒的粒度对实际使用收费
- 只在每个请求的基础上按需运行代码
- 运行响应事件的代码

#### Benefits of Serverless Computing  

- 无需管理服务器
- 持续扩展
- 动态分配资源
- 避免过度分配资源
- 从不为闲置付费:按使用付费

- Serverless is good for short-running，stateless，event-driven  (短时、无状态、事件驱动的)

- Serverless is not good for long-running，stateful，number crunching  (长时、有状态、数值计算的)


- Software as a Service(SaaS)：客户使用运行在云上的应用程序

- Platform as a Service(PaaS)：提供云中的开发和部署平台

- Infrastructure as a Service(IaaS)：为开发人员或系统管理员提供一个虚拟机，他们可以在虚拟机上运行任何操作系统和软件

- 私有云:由单个组织拥有/运营的云基础设施
- 公有云:对一般公众可用的云基础设施
- 社区云:由几个组织共享/支持的云基础设施
- 混合云:上述的组合

------

## MVC, MVP and MVVM: A Comparison of Architectural Patterns  

### “Traditional” Windows Presentation Foundation(WPF) Programming  

![](img\屏幕截图 2021-01-10 162905.png)

#### Pros:

- 简单
- 可以随意操控

#### Cons:

- 非常难以测试
- 不能轻易识别可修改的UI状态
- 使用UI作为数据存储
- 业务逻辑和控制操作混合在一起

### Model-View-Controller (MVC)  

- 模型-数据

- 视图-表示层

- 控制器-分离模型和视图的核心部件

- 控制流:

  -用户交互事件
  -控制器处理事件并将其转换为模型可以理解的用户动作
  -模型管理应用领域的行为和数据
  -视图与控制器和模型交互，生成用户界面

#### Backbone

![](img\屏幕截图 2021-01-10 163442.png)

### Model-View-Presenter (MVP)  

- MVP是MVC的衍生品（MVP中P的功能比MVC中C的功能要多，两者的M差距不大）
- 两种实现类型：被动视图（Passive View），监督控制器（Supervising controller）
- Presenter使用MVC控制器的功能
- View负责处理UI事件
- 模型成为严格的域模型
- 更以用户界面为中心

#### Passive View

![](img\屏幕截图 2021-01-10 163901.png)

#### MVP (passive view)

![](img\屏幕截图 2021-01-10 163949.png)

#### Model View Presenter (supervising controller)  

![](img\屏幕截图 2021-01-10 164331.png)

### Model-View-ViewModel (MVVM)  

- 主要基于MVC

- 被称为Presentation Model的MVP模式的专业化

- 专门为WPF和Silverlight环境构建

- 模型和视图就像MVC一样工作

- ViewModel是一个“视图的模型” (将业务逻辑数据与表现数据分开)

  它用视图可以使用的行为扩展了模型

  视图和模型之间的数据绑定

  在视图和模型之间传递命令

#### The MVVM Pattern

![](img\屏幕截图 2021-01-10 164956.png)

#### MVVM - The View

- 定义结构、布局和外观。
- 只知道ViewModel。
- 理想情况下，它是纯XAML，几乎没有代码。
- 可以拥有自己的ViewModel或从父视图继承。
- 在运行时，UI响应ViewModel属性引发的更改通知事件。
- Windows Phone上的视图通常是应用程序中的一个页面。

#### MVVM - The Model

- 这就是你的领域模型。
- 包括业务和验证逻辑。
- 示例:存储库、业务对象、数据传输对象(DTO)，值对象等。
- 只知道它自己——而不知道视图、控制器等

#### MVVM – The View Model  

- 视图和模型之间的中介。
- 只知道模型。
- 处理视图逻辑。
- 通过调用模型类中的方法与模型交互。
- 以视图可以使用的形式提供来自模型的数据。
- 提供视图使用的命令实现。举例:单击UI上的一个按钮，在View Model中触发一条命令
- 定义状态

#### MVVM – The Benefits  

- 使用developer-designer工作流。
- 开发人员和设计人员可以独立且并发地工作在他们的组件上。
- 开发人员可以创建单元测试，而不需要视图。
- 无需修改代码就可以重新设计UI。
- 视图模型充当一个适配器，允许更容易地更改模型

------

## Quality Attributes  

### Runtime Quality Attributes

#### Performance

- 性能:时间性能、内存、磁盘或网络利用率

- 系统的真正性能不仅仅由单个组件的性能来定义，还包括他们之间的互动和系统中的整体流程

- 影响因子：选择的算法，数据库设计，通信，资源管理

- 策略:

  控制资源需求——减少对资源的需求

  管理资源——更有效地工作

#### Usability

- 可用性:人为因素，易于学习，易于使用

- 策略:

  支持用户主动性——用户完成任务是多么容易

  支持系统主动性——系统对用户的支持

#### Reliability

- 可靠性:可用性、安全性

- 可靠性衡量的是系统的故障率

- 策略:

  检测故障——识别不工作的部件

  从故障中恢复——发生故障时该做什么

  防止故障——如何提高可用性

#### Security

- 安全性:身份验证、数据保护

- 策略:

  抵抗攻击——在攻击发生之前阻止攻击

  检测攻击——识别正在进行的攻击

  对攻击作出反应——在攻击的情况下作出反应

  从攻击中恢复——攻击后采取的行动

### Non-runtime Quality Attributes  

#### Maintainability  

- 允许系统在部署后轻松修改

- 策略:

  减小元件尺寸

  增加凝聚力

  降低耦合

  延迟绑定

#### Testability  

- 改进可测试性的方法

- 策略:

  控制和观察系统状态——使测试更容易

  限制复杂性——复杂的系统更难测试，因此让它们更简单

#### Configurability  

- 无需重新编译或重新安装即可改变系统运行参数的能力

#### Scalability  

- 无需重新编译或重新安装即可增加系统容量的能力

------

## Quality Attributes of Architecture -- Availability  

### Quality Attribute Scenarios  

- 质量属性场景是一个特定于质量属性的需求。它由六个部分组成。
- **刺激来源**。这是产生刺激的某种实体(人、计算机系统或任何其他执行器)。
- **刺激**。当刺激到达一个系统时，需要考虑刺激的条件。
- **环境**。刺激是在一定条件下发生的。当刺激发生时，系统可能处于过载状态或正在运行，或者其他一些情况可能是真的。
- **工件**。某些工件被刺激了。这可能是整个系统或其中的一部分。
- **响应**。响应是刺激到达后所进行的活动。
- **响应测量**。当响应发生时，它应该以某种方式可测量，以便可以测试需求

### Availability

- 刺激来源。

  我们区分故障(faults)或失败(failure)的内部和外部指示，因为期望的系统响应可能不同。

- 刺激。下列类之一的错误发生。

  遗漏。组件无法响应输入。

  崩溃。该部件反复出现遗漏故障。

  时机。组件响应，但响应是早响应或晚响应。

  响应。组件响应一个不正确的值。

- 工件。

  它指定了高可用性所需的资源，例如处理器、通信通道、进程或存储。

- 环境。

  故障或失败发生时的系统状态也可能影响所需的系统响应。例如，如果系统已经发现一些故障，并且正在以非正常模式运行，则可能需要完全关闭它。然而，如果这是观察到的第一个故障，则响应时间或函数的一些退化可能是首选

- 响应。

  系统故障有多种可能的反应。这些包括

  记录故障

  通知选定的用户或其他系统

  切换到降级模式，容量减少或功能减少

  关闭外部系统

  维修期间不可用。

- 响应测量。

  响应测量可以指定可用性百分比，也可以指定修复时间、系统必须保持可用的时间或持续的时间

![](img\屏幕截图 2021-01-10 121250.png)

#### Availability Tactics

![](img\屏幕截图 2021-01-10 124709.png)

------

## Quality Attributes of Architecture -- Modifiability & Security  

### Modifiability

- 刺激来源。

  该部分指定由谁进行更改，开发人员、系统管理员或最终用户。显然，必须有允许系统管理员或最终用户修改系统的机制，但这是常见的情况。

- 刺激。

  该部分指定要进行的更改。

- 工件。

  这部分指定要更改的内容。一个系统的功能，它的平台，它的用户界面，它的环境，或者它与之交互的另一个系统

- 环境。

  该部分指定了可以进行更改的时间。设计时、编译时、构建时、启动时或运行时

- 响应。

  做改变的人必须知道如何做，然后做，测试和部署。

- 响应测量。

  所有可能的反应都需要时间和金钱，所以时间和金钱是最理想的测量。然而，时间并不总是可以预测的，因此经常使用不太理想的度量，例如更改的程度(受影响的模块数量)

![](img\屏幕截图 2021-01-10 125514.png)

#### Modifiability Tactics

![](img\屏幕截图 2021-01-10 125731.png)

### Security

- 刺激来源。

  攻击的来源可能是一个人或另一个系统。它可能已经被预先识别(正确或错误)，也可能是目前未知的。

  攻击本身就是未经授权的访问、修改或拒绝服务。

- 刺激。

  刺激是一种破坏安全的攻击或企图。

  我们将此行为定义为未经授权的个人或系统试图显示信息、更改和/或删除信息、访问系统服务或减少系统服务的可用性。

- 工件。

  攻击的目标可以是系统的服务，也可以是系统中的数据。

- 环境。

  当系统处于在线或离线状态、连接到或断开到网络、在防火墙后或对网络开放时，攻击就会发生。

- 响应。

  未经授权使用服务或阻止合法用户使用服务与查看或修改敏感数据是不同的目标。因此，系统必须授权合法用户，允许他们访问数据和服务，同时拒绝非法用户，拒绝他们访问，并报告非法访问。

- 响应测量。

  系统响应的测量包括发动各种攻击的难度以及从攻击中恢复和幸存的难度

![](img\屏幕截图 2021-01-10 130340.png)

#### Security Tactics

![](img\屏幕截图 2021-01-10 130512.png)

------

## Quality Attributes of Architecture -- Performance  

- 刺激来源。

  刺激要么来自外部(可能是多个)，要么来自内部。

- 刺激。

  刺激是事件的到达。到达模式可以是周期性的，随机的，或零星的。

- 工件。

  工件总是系统的服务。

- 环境。

  系统可以处于各种运行模式，如正常、紧急或过载。

- 响应。

  系统必须处理到达的事件。这可能导致系统环境发生变化(例如，从正常模式变为过载模式)。

- 响应测量。

  响应测量是所花费的时间,处理到达的事件(延迟或最后期限的事件必须处理),这次的变化(抖动),处理事件的数量在一个特定的时间间隔(吞吐量),或无法处理的事件的描述(错过率,数据丢失)

![](img\屏幕截图 2021-01-10 131334.png)

#### Performance Tactics  

![](img\屏幕截图 2021-01-10 131459.png)

------

## Quality Attributes of Architecture -- Testability & Usability  

### Testability

- 刺激来源。

  单元测试人员、集成测试人员、系统测试人员或客户端测试人员。设计的测试可以由其他开发人员或外部团队执行。

- 刺激。

  测试的刺激因素是满足了开发过程中的一个里程碑。

- 工件。

  一个设计，一段代码，或者整个系统都是被测试的工件。

- 环境。

  测试可以在设计时、开发时、编译时或部署时进行。

- 响应。

  由于可测试性与可观察性和可控性有关，期望的响应是系统可以被控制以执行期望的测试，并且每个测试的响应都可以被观察到。

- 响应测量。

  响应测量是在某些测试中执行的语句的百分比、最长测试链的长度(执行测试难度的度量)以及可能出现额外错误的概率估计值。

![](img\屏幕截图 2021-01-10 132555.png)

#### Testability Tactics

![](img\屏幕截图 2021-01-10 132937.png)

### Usability

- 刺激来源。

  最终用户总是刺激的来源。

- 刺激。

  最终用户希望有效地使用系统，学习使用系统，最小化错误的影响，适应系统，或者对系统感到舒适。

- 工件。

  工件总是系统。

- 环境。

  与可用性有关的用户操作总是在运行时或系统配置时发生。

- 响应。

  系统应该要么为用户提供所需的特性，要么预测用户的需求。

- 响应措施。

  响应是通过任务时间、错误数量、解决的问题数量、用户满意度、用户知识的获得、成功操作与总操作的比率，或错误发生时的时间、数据丢失量来衡量的

![](img\屏幕截图 2021-01-10 133500.png)

#### Usability Tactics

![](img\屏幕截图 2021-01-10 133635.png)

------

## OO Design Principles  

### Single Responsibility Principle  

- 单一职责原则
- 一个实体(一个对象，一个类)应该只有一个职责
- 责任实际上是改变的理由，一个实体应该只有一个改变的理由
- 试着让每个类负责软件所提供的功能的单一部分，并让这种责任完全封装在类中(也可以说是隐藏在类中)

![](img\屏幕截图 2021-01-10 143028.png)

![](img\屏幕截图 2021-01-10 143114.png)

### Open-Closed Principle  

- 开闭原则
- 类应该对扩展开放，对修改关闭
- 换句话说，您应该能够在不修改类的情况下扩展它
- **开放扩展**:类的行为可以扩展，以满足不断变化的需求
- **关闭修改**:类本身不允许更改
- 通过继承现有的基类来添加新的代码和类来扩展设计
- 不需要修改现有的类，已完成和测试的代码被声明为关闭，并且永远不会被修改

![](img\屏幕截图 2021-01-10 141002.png)

![](img\屏幕截图 2021-01-10 141105.png)

### Liskov Substitution Principle  

- 里氏替换原则

- 如果对于每一个类型为S的对象o1都有一个类型为T的对象o2。对于用T定义的所有程序P，当o1替换o2时，P的行为没有改变，那么S是T的子类型。

- 在指定基类型的任何地方，都应该能够使用派生类型的实例

- 被重载的方法需要满足父类指定的规则

- 问题由来：

  有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的
  功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类A
  的子类B来完成，则子类B在完成新功能P2的同时，有可能会导
  致原有功能P1发生故障。  

- 解决方案：

  当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新
  的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量
  不要重载父类A的方法。  

- 子类可以扩展父类的功能，但不能改变父类原有的功能。
  它包含以下4层含义：

  – 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。

  – 子类中可以增加自己特有的方法。

  – 当子类的方法**重载**父类的方法时，方法的**前置条件**（即方法的形参）要比父类方法的输入参数**更宽松**。

  – 当子类的方法**实现**父类的**抽象方法**时，方法的**后置条件**（即方法的返回值）要比父类**更严格**  

![](img\屏幕截图 2021-01-10 142124.png)

![](img\屏幕截图 2021-01-10 142229.png)

### Interface Segregation Principle  

- 接口隔离原则
- 不应该强迫客户依赖于他们不使用的方法
- 尽量使您的接口足够窄，这样客户端类就不必实现它们不需要的行为
- 根据接口隔离原则，应该将“胖”接口分解为更细粒度和更特殊的接口。客户端应该只实现它们真正需要的那些方法。

![](img\屏幕截图 2021-01-10 145304.png)



![](img\屏幕截图 2021-01-10 145401.png)

### Dependency Inversion Principle  

- 依赖倒置原则
- 高级类不应该依赖低级类。两者都应该依赖于抽象。抽象不应该依赖于细节。细节应该依赖于抽象

![](img\屏幕截图 2021-01-10 145735.png)

- 您可以通过创建一个高级接口来描述读/写操作，并让BudgetReport类使用该接口而不是低级类来解决这个问题。然后您可以更改或扩展原始的低级类，以实现由业务逻辑声明的新的读/写接口

![](img\屏幕截图 2021-01-10 145857.png)

### Law of Demeter  

- 最少知识原则  
- 一个对象的方法应该只调用以下方法: 本身、它的参数、创建的对象、其成员
- 方法不应该调用其他对象成员的方法

### Divide and conquer  

- 试图一次性处理一件大事情通常比处理一系列较小的、可管理的、可理解的事情困难得多
- 因此，软件开发的迭代方法
- 单个组件更小，更容易理解
- 零件可以更换或改变，而不必更换或大量改变其他零件

#### Ways of dividing a software system  

- 分布式系统分为客户端和服务器
- 系统被划分为多个子系统
- 一个子系统可以被划分为一个或多个包
- 包被划分为类
- 类被划分为方法

### High Cohesion  

- 如果子系统或模块将相互关联的事物放在一起，并将其他事物拒之门外，那么它就具有高内聚性

- 内聚种类：

  Functional, Layer, Communicational, Sequential, Procedural, Temporal, Utility  

### Low Coupling  

- 当一个模块和另一个模块之间存在相互依赖时，就会发生耦合

- 耦合种类：

  Content, Common, Control, Stamp, Data, Routine Call, Type use,
  Inclusion/Import, External  

### Enterprise Architecture Principles  

- Reuse
- Buy rather than build
- Single point of view

------

## Design Pattern

### pattern与algorithm区别

While an algorithm always defines a clear set of actions that can achieve some goal, a pattern is a more high-level description of a solution.   

### 工厂方法

直接使用new操符-->调用工厂方法 以生成对象，这些对象有一个公共的基类或接口，工厂方法return  type：公共基类或接口

![](img\屏幕截图 2021-01-08 104708.png)

#### Pros：

单一原则、开闭原则

#### Cons：

增加代码复杂度

#### 与其他Patterns的关系：

- 许多设计从使用工厂方法开始(不那么复杂，通过子类更容易定制)，然后发展到抽象工厂、原型或构建器(更灵活，但更复杂)。
- 抽象工厂类通常基于一组工厂方法，但是您也可以使用Prototype来组合这些类上的方法。
- 您可以使用工厂方法和迭代器来让集合子类返回与集合兼容的不同类型的迭代器。
- 原型不是基于继承的，所以它没有继承的缺点。另一方面，Prototype需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。
- 工厂方法是模板方法的特化。同时，工厂方法可以作为大型模板方法中的一个步骤。

### 抽象工厂

1. 抽象工厂模式建议的第一件事是显式地为产品族中的每个不同产品声明接口(例如，椅子、沙发或茶几)。然后你就可以让所有的产品变种都遵循这些接口。例如，所有椅子变体都可以实现Chair接口;所有的咖啡桌变体都可以实现CoffeeTable接口，等等
2. 下一步是将抽象工厂声明为一个接口，该接口包含产品家族中所有产品的创建方法列表(例如，createChair、createSofa和createCoffeeTable)。这些方法必须返回由前面提取的接口表示的抽象产品类型:Chair、Sofa、CoffeeTable等等

![](img\屏幕截图 2021-01-08 104759.png)

#### Pros:

- 你可以确信从工厂得到的产品是互相兼容的。
- 您可以避免具体产品和客户机代码之间的紧密耦合。
- 单一责任原则。您可以将产品创建代码提取到一个地方，使代码更容易支持。
- 打开/关闭原则。您可以在不破坏现有客户机代码的情况下引入产品的新变种

#### Cons:

- 代码可能变得比它应该的更加复杂，因为随着模式的引入，引入了许多新的接口和类

#### 与其他Patterns的关系：

- Builder专注于一步一步地构建复杂对象。抽象工厂专门创建一系列相关的对象。抽象工厂立即返回产品，而Builder允许您在获取产品之前运行一些额外的构造步骤。
- 抽象工厂类通常基于一组工厂方法，但是您也可以使用Prototype来组合这些类上的方法。
- 当您只想从客户机代码中隐藏创建子系统对象的方式时，抽象工厂可以作为Facade的替代方案。
- 您可以使用抽象工厂和桥。当Bridge定义的某些抽象只能与特定的实现一起工作时，这种配对很有用。在这种情况下，抽象工厂可以封装这些关系，并对客户端代码隐藏复杂性。
- 抽象工厂、构建器和原型都可以作为单例实现。

### 建造者模式

1. 建造模式建议您从类中提取对象构建代码，并将其移动到称为建造者的单独对象中
2. 该模式将对象构造组织成一组步骤(建造墙，建造门，等等)。要创建对象，需要在建造者对象上执行一系列步骤。重要的是，您不需要调用所有的步骤。您只能调用生成对象的特定配置所必需的步骤。当您需要构建产品的各种表示时，一些构建步骤可能需要不同的实现。例如，小屋的墙可以用木头建造，但城堡的墙必须用石头建造
3. 建造者模式允许您一步一步地构造复杂的对象。建造者不允许其他对象在构建产品时访问该产品
4. 提取一系列对建造者步骤的调用，这些步骤用于将产品构造为名为director的单独类。**director类定义执行建造步骤的顺序，而建造者提供这些步骤的实现**

![](img\屏幕截图 2021-01-08 122429.png)

#### Pros：

- 您可以逐步构造对象、延迟构造步骤或递归地运行步骤。
- 在构建产品的不同表现形式时，可以重复使用相同的构造代码。
- 单一责任原则。您可以将复杂的构造代码从产品的业务逻辑中隔离出来

#### Cons：

- 由于模式需要创建多个新类，代码的总体复杂性增加了。

#### 与其他Patterns的关系：

- 在创建复杂的复合树时可以使用Builder，因为可以对其构造步骤进行编程，使其递归工作。
- 您可以将Builder与Bridge结合起来：director类扮演抽象的角色，而不同的builders扮演实现。

### 原型

1. 原型模式将克隆过程委托给被克隆的实际对象。该模式为支持克隆的所有对象声明一个公共接口。该接口允许您克隆一个对象，而无需将代码耦合到该对象的类。通常，这样的接口只包含一个克隆方法
2. 克隆方法的实现在所有类中都非常相似。该方法创建当前类的一个对象，并将旧对象的所有字段值转移到新对象中。您甚至可以复制私有字段，因为大多数编程语言允许对象访问属于同一类的其他对象的私有字段

![](img\屏幕截图 2021-01-08 193050.png)

#### Pros：

- 您可以克隆对象，而不必耦合到它们的具体类。
- 你可以摆脱重复的初始化代码，以支持克隆预构建的原型。
- 你可以更方便地生成复杂的对象。
- 当处理复杂对象的配置预设时，你得到了继承的替代方案

#### Cons：

- 克隆具有循环引用的复杂对象可能非常棘手

#### 与其他Patterns的关系：

- 当您需要将Commands副本保存到历史记录中时，Prototype可以提供帮助。
- 大量使用Composite和Decorator的设计通常可以从使用原型中获益。应用该模式可以克隆复杂的结构，而不是从头重新构建它们。
- 原型不是基于继承的，所以它没有它的缺点。另一方面，Prototype需要对克隆对象进行复杂的初始化。工厂方法基于继承，但不需要初始化步骤。
- 有时候原型可以是Memento更简单的替代品。如果对象(您想要将其状态存储在历史记录中)相当简单且没有指向外部资源的链接，或者这些链接很容易重新建立，那么这种方法就可以工作。

### 单例

1. 将默认构造函数设为私有，以防止其他对象在Singleton类中使用new操作符
2. 创建一个充当构造函数的静态创建方法。在底层，这个方法调用私有构造函数来创建对象，并将其保存在静态字段中。对该方法的所有后续调用都将返回缓存的对象

#### 与静态变量的区别：

​    静态变量常驻内容，可能会引起安全问题等，不建议使用，一般采用静态方法，而Singleton不会引起安全问题，同时可以添加一些新的方法

![](img\屏幕截图 2021-01-08 194825.png)

#### Pros：

- 可以确定一个类只有一个实例。
- 你获得了该实例的全局访问点。
- 单例对象只有在第一次被请求时才被初始化。

#### Cons：

- 违反单一责任原则。该模式同时解决了两个问题。
- Singleton模式可以掩盖糟糕的设计,例如,当程序的组件彼此太多的了解。
- 模式要求特殊待遇在多线程环境中,多个线程不会多次创建一个单例对象。
- 对单例的客户端代码进行单元测试可能比较困难，因为许多测试框架在生成模拟对象时依赖于继承。由于单例类的构造函数是私有的，而且在大多数语言中不可能覆盖静态方法，所以您需要想出一种创造性的方法来模拟单例。或者干脆不写测试。或者不要使用单例模式。

#### 与其他Patterns的关系：

- Facade类通常可以转换为单例，因为在大多数情况下单个Facade对象就足够了。
- 如果您设法将所有对象的共享状态减少为一个Flyweight对象，那么Flyweight将类似于Singleton。但是这些模式之间有两个基本区别:应该只有一个单例实例，而Flyweight类可以有多个具有不同内在状态的实例。单例对象可以是可变的。Flyweight对象是不可变的

### 适配器模式

1. 您可以创建适配器。这是一个特殊的对象，它转换一个对象的接口，以便另一个对象能够理解它
2. 适配器包装了其中一个对象，以隐藏幕后发生的转换的复杂性。被包装的对象甚至不知道适配器。例如，您可以用一个适配器包装一个以米和公里为单位的对象，该适配器将所有数据转换为英尺和英里等英制单位
3. 有时甚至可以创建一个双向适配器，可以在两个方向上转换调用

![](img\屏幕截图 2021-01-08 200855.png)

#### Pros：

- 单一责任原则。您可以将接口或数据转换代码与程序的主要业务逻辑分离。
- 打开/关闭原则。您可以在程序中引入新类型的适配器，而不会破坏现有的客户机代码，只要它们通过客户机接口与适配器一起工作即可

#### Cons：

- 由于需要引入一组新的接口和类，代码的总体复杂性增加了。有时更改服务类使其与代码的其余部分匹配会更简单。

#### 与其他Patterns的关系：

- Bridge通常是预先设计的，允许您独立地开发应用程序的各个部分。另一方面，Adapter通常与现有的应用程序一起使用，以使一些不兼容的类很好地协同工作。
- 适配器更改现有对象的接口，而装饰器增强对象而不更改其接口。此外，Decorator支持递归组合，这在使用适配器时是不可能的。
- 适配器为包装的对象提供不同的接口，代理为其提供相同的接口（用同一接口做不同的事），装饰器为其提供增强的接口。
- Facade为现有对象定义了一个新接口，而Adapter则试图使现有接口可用。适配器通常只包装一个对象，而Facade使用对象的整个子系统。
- Bridge、状态、策略(以及某种程度上的适配器)具有非常相似的结构。实际上，所有这些模式都是基于组合的，即将工作委托给其他对象。然而，它们都解决不同的问题。模式不只是以特定方式构造代码的诀窍。它还可以将模式解决的问题传达给其他开发人员。

### 桥模式

1. 桥接模式试图通过**从继承转换到对象组合**来解决这个问题。这意味着您将一个维提取到一个单独的类层次结构中，这样原始类将引用新层次结构的对象，而不是将其所有的状态和行为都放在一个类中

   ![](img\屏幕截图 2021-01-08 204139.png)

2. 按照这种方法，我们可以将与颜色相关的代码提取到它自己的类中，该类有两个子类:Red和Blue。Shape类然后获得一个指向其中一个颜色对象的引用字段。现在，形状可以将任何与颜色相关的工作委托给链接的颜色对象。该引用将充当Shape和Color类之间的桥梁。从现在开始，添加新的颜色不需要改变形状层次结构，反之亦然

![](img\屏幕截图 2021-01-08 203929.png)

#### Pros：

- 您可以创建与平台无关的类和应用程序。
- 客户端代码使用高级抽象。它没有公开平台细节。
- 打开/关闭原则。您可以引入彼此独立的新的抽象和实现。
- 单一责任原则。您可以关注抽象中的高级逻辑，以及实现中的平台细节

#### Cons：

- 通过将模式应用于高度内聚的类，可能会使代码更加复杂。

#### 与其他Patterns的关系：

- 您可以使用抽象工厂和桥。当Bridge定义的某些抽象只能与特定的实现一起工作时，这种配对很有用。在这种情况下，抽象工厂可以封装这些关系，并对客户端代码隐藏复杂性。
- 您可以将Builder与桥结合起来：director类扮演抽象的角色，而不同的builders扮演实现。

### 组合模式

- 组合模式建议您通过一个公共接口来处理产品和盒子，该接口声明了计算总价的方法
- 这个方法是如何工作的呢?对于一个产品，它只返回产品的价格。对于一个盒子，它会检查盒子中包含的每一件物品，询问价格，然后返回这个盒子的总价。如果其中一个项目是一个更小的盒子，这个盒子也会开始遍历它的内容，以此类推，直到所有内部组件的价格都计算出来。一个盒子甚至可能会在最终价格上增加一些额外的成本，比如包装成本
- 这种方法最大的好处是，您不需要关心组成树的对象的具体类。你不需要知道一个物体是一个简单的产品还是一个复杂的盒子。您可以通过公共接口对它们进行相同的处理。当您调用一个方法时，对象本身将请求传递到树中

![](img\屏幕截图 2021-01-08 215238.png)

#### Pros：

- 您可以更方便地处理复杂的树结构:使用多态和递归为您的优势。
- 打开/关闭原则。您可以在不破坏现有代码的情况下将新元素类型引入应用程序，现有代码现在可以与对象树一起工作

#### Cons：

- 为功能差异太大的类提供一个通用接口可能很困难。在某些情况下，您需要将组件接口过度一般化，从而使其难以理解

#### 与其他Patterns的关系：

- 在创建复杂的组合树时可以使用Builder，因为可以对其构造步骤进行编程，使其递归工作。
- 责任链常与组合模式连用。在这种情况下，当叶组件获得一个请求时，它可能会通过所有父组件链向上传递请求到对象树的根。
- 您可以使用迭代器来遍历复合树。
- 您可以使用Visitor在整个复合树上执行操作。
- 可以将复合树的共享叶节点实现为Flyweights，以节省一些RAM。
- 复合和装饰器有类似的结构图，因为它们都依赖递归组合来组织开放数量的对象。
- 装饰器类似于组合，但只有一个子组件。还有另一个显著的区别:Decorator为被包装的对象增加了额外的职责，而组合只是总结它的子对象的结果。
- 然而，这些模式也可以相互协作:您可以使用Decorator来扩展组合树中特定对象的行为。
- 大量使用组合和装饰器的设计通常可以从使用原型中获益。应用该模式可以克隆复杂的结构，而不是从头重新构建它们

### 装饰模式（Decorator）

1. 包装器是装饰器模式的另一个别名，它清楚地表达了模式的主要思想。包装器是可以与某些目标对象链接的对象。包装器包含与目标相同的一组方法，并将它接收到的所有请求委托给它。但是，包装器可以在将请求传递给目标之前或之后执行某些操作，从而改变结果。
2. 一个简单的包装器何时才能成为真正的装饰器?如前所述，包装器实现了与被包装对象相同的接口。这就是为什么从客户的角度来看，这些对象是相同的。使包装器的引用字段接受该接口后面的任何对象。这将允许您在多个包装器中覆盖一个对象，并将所有包装器的组合行为添加到其中。
3. 在我们的通知示例中，让我们将简单的电子邮件通知行为留在基本通知器类中，但将所有其他通知方法转换为装饰器

![](img\屏幕截图 2021-01-08 221606.png)

#### Pros:

- 你可以扩展一个对象的行为而不需要创建一个新的子类。
- 您可以在运行时从对象中添加或删除责任。
- 通过将一个对象包装到多个装饰器中，可以组合几种行为。
- 单一责任原则。您可以将实现许多可能的行为变体的整体类划分为几个较小的类。

#### Cons:

- 很难从包装器堆栈中删除特定的包装器。
- 要实现一个装饰器，其行为不依赖于装饰器堆栈中的顺序，是很困难的。
- 层的初始配置代码可能看起来非常难看

#### 与其他Patterns的关系：

- 适配器改变现有对象的接口，而装饰器增强对象而不改变其接口。此外，Decorator支持递归组合，这在使用适配器时是不可能的。
- 适配器为被包装的对象提供不同的接口，代理为其提供相同的接口（同一接口不同操作），装饰器为其提供增强的接口。
- 责任链和装饰器有非常相似的类结构。两种模式都依赖于递归组合来通过一系列对象传递执行。然而，有几个关键的区别。
- 责任链处理程序可以彼此独立地执行任意操作。它们还可以在任何时候停止进一步传递请求。另一方面，各种装饰器可以扩展对象的行为，同时保持其与基接口的一致。此外，decorator不允许中断请求流。
- Composite和Decorator具有类似的结构图，因为它们都依赖递归组合来组织无限制数量的对象。
- 装饰器类似于组合，但只有一个子组件。还有另一个显著的区别:Decorator向被包装的对象添加了额外的责任，而Composite只总结其子对象的结果。
- 然而，这些模式也可以相互配合:您可以使用装饰器来扩展复合树中特定对象的行为。
- 大量使用组合和装饰器的设计通常可以从使用原型中受益。应用该模式可以克隆复杂的结构，而不必从头重新构造它们。
- 装饰器让你改变对象的外观，而策略让你改变内部结构。
- 装饰器和代理具有相似的结构，但意图却截然不同。两种模式都建立在组合原则的基础上，其中一个对象应该将一些工作委托给另一个对象。不同之处在于，代理通常独自管理其服务对象的生命周期，而装饰器的组合总是由客户端控制

### 外观模式（Facade）

1. Facade是一个类，它为包含许多活动部件的复杂子系统提供了一个简单的接口。与直接使用子系统相比，Facade提供的功能可能有限。然而，它只包含那些客户真正关心的特性
2. 当您需要将应用程序与具有数十个特性的复杂库集成在一起时，拥有Facade是很方便的，但您只需要它的一小部分功能
3. 例如，一个应用程序上传与猫有关的搞笑短视频到社交媒体上，可能会使用专业的视频转换库。然而，它真正需要的是一个具有单个方法encode(filename, format)的类。创建这样的类并将其与视频转换库连接之后，您将拥有第一个Facade

![](img\屏幕截图 2021-01-08 223553.png)

#### Pros:

- 您可以将代码与子系统的复杂性隔离开来
- 满足接口隔离原则

#### Cons:

- Facade可以成为与应用程序的所有类耦合的god对象

#### 与其他Patterns的关系：

- Facade为现有对象定义了一个新接口，而Adapter则试图使现有接口可用。适配器通常只包装一个对象，而Facade使用对象的整个子系统。
- 当您只想从客户机代码中隐藏创建子系统对象的方式时，抽象工厂可以作为Facade的替代方案。
- Flyweight展示了如何创建许多小对象，而Facade展示了如何创建表示整个子系统的单个对象。
- Facade和Mediator的工作类似:它们试图在许多紧密耦合的类之间组织协作。
- Facade定义了一个到对象子系统的简化接口，但是它并没有引入任何新功能。子系统本身不知道Facade。子系统中的对象可以直接通信。
- Mediator集中系统组件之间的通信。组件只知道Mediator对象，不直接通信。
- Facade类通常可以转换为单例，因为在大多数情况下单个Facade对象就足够了。
- Facade与代理相似，都对复杂的实体进行缓冲并自行初始化。与Facade不同，Proxy具有与其服务对象相同的接口，这使得它们可以互换

### 享元模式（Flyweight，Cache）

- 该模式从主树类中提取重复的内在状态，并将其移动到flyweight类树类型中。
- 现在，不再将相同的数据存储在多个对象中，而是将其保存在几个flyweight对象中，并链接到充当上下文的适当的树对象。客户机代码使用flyweight工厂创建新的树对象，它封装了搜索正确对象并在需要时重用它的复杂性

![](img\屏幕截图 2021-01-08 231202.png)

#### Pros:

- 如果您的程序中有大量类似的对象，那么您可以节省大量的RAM

#### Cons:

- 当某些上下文数据需要在每次调用flyweight方法时重新计算时，您可能需要用CPU周期交换RAM。
- 代码变得更加复杂。新的团队成员总是想知道为什么实体的状态是以这样的方式分离的

#### 与其他Patterns的关系：

- 可以将复合树的共享叶节点实现为Flyweight，以节省一些RAM。
- Flyweight展示了如何创建许多小对象，而Facade展示了如何创建表示整个子系统的单个对象。
- 如果您设法将所有对象的共享状态减少为一个Flyweight对象，那么Flyweight将类似于Singleton。但这些模式之间有两个根本的区别:
- 应该只有一个单例实例，而Flyweight类可以有多个具有不同内在状态的实例。
- 单例对象可以是可变的。Flyweight对象是不可变的

### 代理模式（Proxy）

- 代理类有一个指向服务对象的引用字段。在代理完成其处理(例如，延迟初始化、日志记录、访问控制、缓存等)后，它将请求传递给服务对象。通常，代理管理其服务对象的整个生命周期

![](img\屏幕截图 2021-01-08 235041.png)

#### Applicability:

- 延迟初始化(虚拟代理)。当您有一个重量级的服务对象，它总是处于启动状态，从而浪费了系统资源，即使您只是偶尔需要它。
- 访问控制(保护代理)。此时，您希望只有特定的客户端能够使用服务对象;例如，当您的对象是操作系统的关键部分，而客户机是各种启动的应用程序(包括恶意的应用程序)时。
- 远程服务(远程代理)的本地执行。此时服务对象位于远程服务器上。
- 记录请求(记录代理)。此时，您需要保存对服务对象的请求历史记录。
- 缓存请求结果(缓存代理)。此时，您需要缓存客户机请求的结果并管理此缓存的生命周期，特别是在结果非常大的情况下。
- 智能引用。此时，您需要能够在没有客户端使用重量级对象时解散它。

#### Pros:

- 您可以在客户端不知道的情况下控制服务对象。
- 当客户端不关心时，你可以管理服务对象的生命周期。
- 即使服务对象没有准备好或不可用，代理也可以工作。
- 开放/封闭原则。您可以引入新的代理，而无需更改服务或客户端

#### Cons:

- 由于需要引入很多新类，代码可能会变得更复杂。
- 来自服务的响应可能会推迟

#### 与其他Patterns的关系：

- Facade与代理相似，都对复杂的实体进行缓冲并自行初始化。与Facade不同，Proxy具有与其服务对象相同的接口，这使得它们可以互换。
- 装饰器和代理具有相似的结构，但意图非常不同。这两种模式都建立在组合原则的基础上，其中一个对象应该将一些工作委托给另一个对象。不同之处在于，**代理通常自己管理其服务对象的生命周期，而装饰器的组合总是由客户机控制**

### 责任链（Chain of Responsibility）

- 允许您沿着处理程序链传递请求。在接收到请求时，每个处理程序决定是处理请求还是将其传递给链中的下一个处理程序
- 该模式建议将这些处理程序链接到一个链中。每个链接的处理程序都有一个字段，用于存储对链中下一个处理程序的引用。除了处理请求之外，处理程序还会沿着请求链进一步传递请求。请求沿着链移动，直到所有处理程序都有机会处理它
- 这里是最好的部分:处理程序可以决定不将请求向下传递，并有效地停止任何进一步的处理
- 但是，还有一种稍微不同的方法(而且更规范一些)，在这种方法中，当接收到请求时，处理程序决定是否可以处理请求。如果可以，它将不再传递请求。因此，要么只有一个处理程序来处理请求，要么根本没有。在图形用户界面中处理元素堆栈中的事件时，这种方法非常常见

![](img\屏幕截图 2021-01-09 002018.png)

#### Pros:

- 您可以控制请求处理的顺序。
- 单一责任原则。可以将调用操作的类与执行操作的类解耦。
- 开放/封闭原则。您可以在不破坏现有客户端代码的情况下将新的处理程序引入应用程序。

#### Cons:

- 有些请求可能最终没有得到处理

#### 与其他Patterns的关系：

- 责任链、命令、中介和观察者解决了连接请求的发送者和接收者的各种方式:
- 责任链沿着潜在接收者的动态链顺序传递请求，直到其中一个接收者处理它。
- 命令在发送方和接收方之间建立单向连接。
- Mediator消除了发送方和接收方之间的直接连接，迫使它们通过Mediator对象进行间接通信。
- 观察者允许接收者动态地订阅和退订接收请求。
- 责任链常与组合连用。在这种情况下，当叶组件获得一个请求时，它可能会通过所有父组件链向上传递请求到对象树的根。
- 责任链中的处理程序可以作为命令实现。在这种情况下，您可以在同一个上下文对象上执行许多不同的操作(由请求表示)。
- 然而，还有另一种方法，其中请求本身是一个命令对象。在这种情况下，您可以在链接到一个链中的一系列不同上下文中执行相同的操作。
- 责任链和装饰器有非常相似的类结构。这两种模式都依赖于递归组合，通过一系列对象来执行。然而，有几个关键的区别。
- 责任链处理程序可以彼此独立地执行任意操作。它们还可以在任何时候停止进一步传递请求。另一方面，各种装饰器可以扩展对象的行为，同时使其与基本接口保持一致。此外，不允许装饰器破坏请求流。

### 命令模式（Command）

- 将请求转换为包含有关请求所有信息的独立对象。此转换允许您对不同请求的方法进行参数化，延迟或排队执行请求，并支持可撤消的操作
- Command模式建议GUI对象不应该直接发送这些请求。相反，您应该提取所有请求细节，如被调用的对象、方法名称和参数列表，并将其放入一个单独的命令类中，该命令类只有一个方法来触发该请求。
- 命令对象充当各种GUI和业务逻辑对象之间的链接。从现在开始，GUI对象不需要知道什么业务逻辑对象将接收请求以及如何处理请求。GUI对象只是触发处理所有细节的命令。
- 下一步是让您的命令实现相同的接口。通常它只有一个没有参数的执行方法。这个接口允许您使用同一个请求发送者的各种命令，而不需要将其与具体的命令类耦合。作为奖励，现在您可以切换链接到发送者的命令对象，从而有效地在运行时更改发送者的行为。
- 您可能已经注意到这个谜题中遗漏了一个部分，那就是请求参数。GUI对象可能已经为业务层对象提供了一些参数。由于命令执行方法没有任何参数，我们如何将请求详细信息传递给接收方?结果是，该命令应该预先配置这些数据，或者能够自己获取这些数据

![](img\屏幕截图 2021-01-09 003821.png)

![](E:\backup\Backup-of-postgraduate-study-materials\软件体系结构 丁箐\img\屏幕截图 2021-01-13 113912.png)

#### Pros：

- 单一责任原则。可以将调用操作的类与执行这些操作的类解耦。
- 开放/封闭原则。你可以在不破坏现有客户端代码的情况下引入新的命令到应用程序中。
- 你可以实现撤销/重做。
- 你可以实现延迟执行操作。
- 你可以将一组简单的命令组合成一个复杂的命令。

#### Cons：

- 由于在发送方和接收方之间引入了一个全新的层，代码可能会变得更加复杂

#### 与其他Patterns的关系：

- 执行“撤消”时，可以同时使用“命令”和“备忘录”。在这种情况下，命令负责在目标对象上执行各种操作，而备忘录则在命令执行之前保存该对象的状态。
- 命令和策略看起来可能很相似，因为您可以使用它们来用一些操作参数化对象。然而，它们的目的却截然不同。
- 您可以使用Command将任何操作转换为对象。操作参数成为该对象的字段。这种转换允许您延迟操作的执行、将其排队、存储命令的历史记录、将命令发送到远程服务，等等。
- 另一方面，策略通常描述做同一件事的不同方法，允许您在单个上下文类中交换这些算法。
- 当您需要将命令副本保存到历史记录中时，Prototype可以提供帮助。
- 您可以将Visitor视为命令模式的强大版本。它的对象可以在不同类的不同对象上执行操作。

### 迭代器（Iterator）

1. 允许您遍历集合的元素，而不暴露其底层表示(列表、堆栈、树等)。
2. 迭代器模式的主要思想是将集合的遍历行为提取到称为迭代器的单独对象中
3. 将"遍历"这个方法变成一个类符合refactor（重构）原则，改成类可以多态采用不同的遍历方法，而不用修改客户端程序。

![](img\屏幕截图 2021-01-09 005209.png)

#### Pros：

- 单一责任原则。您可以通过将庞大的遍历算法提取到单独的类中来理清客户机代码和集合。
- 开放/封闭原则。您可以实现新的集合和迭代器类型，并将它们传递给现有代码，而不会破坏任何东西。
- 可以并行迭代同一个集合，因为每个迭代器对象都包含自己的迭代状态。
- 出于同样的原因，你可以延迟迭代并在需要的时候继续迭代

#### Cons：

- 如果你的应用程序只使用简单的集合，那么应用这个模式就太过了。
- 使用迭代器可能效率不及直接经历一些专业的元素集合

#### 与其他Patterns的关系：

- 您可以使用迭代器来遍历复合树。
- 你可以使用工厂方法和迭代器来让集合子类返回与集合兼容的不同类型的迭代器。
- 你可以使用Memento和Iterator来捕获当前的迭代状态，并在必要时回滚它。
- 您可以使用Visitor和Iterator来遍历复杂的数据结构，并对其元素执行一些操作，即使它们都有不同的类

### 中介者模式（Mediator）

- 该模式限制了对象之间的直接通信，并强制它们仅通过中介对象进行协作
- Mediator模式建议您应该停止希望相互独立的组件之间的所有直接通信。相反，这些组件必须通过调用特殊的中介对象来间接协作，该中介对象将调用重定向到适当的组件。因此，组件只依赖于一个中介类，而不是与几十个其他组件耦合

![](img\屏幕截图 2021-01-09 010121.png)

#### Pros：

- 单一责任原则。您可以将不同组件之间的通信提取到一个地方，使其更容易理解和维护。
- 开放/封闭原则。您可以引入新的中介，而不必更改实际的组件。
- 你可以减少程序中不同组件之间的耦合。
- 你可以更容易地重用单个组件

#### Cons：

- 随着时间的推移，一个mediator可以演变成一个God对象

#### 与其他Patterns的关系：

- Facade和Mediator的工作类似:它们试图在许多紧密耦合的类之间组织协作。
- Facade定义了一个到对象子系统的简化接口，但是它并没有引入任何新功能。子系统本身不知道Facade。子系统中的对象可以直接通信。
- Mediator集中系统组件之间的通信。组件只知道中介对象，不直接通信。
- 中介者和观察者之间的区别往往难以捉摸。在大多数情况下，您可以实现这些模式中的任何一种;但有时你可以同时应用这两种方法。我们来看看怎么做。
- Mediator的主要目标是消除一组系统组件之间的相互依赖关系。相反，这些组件依赖于单个中介对象。观察者的目标是在对象之间建立动态单向连接，其中一些对象作为其他对象的下属。
- 有一种依赖于观察者的中介者模式的流行实现。中介对象扮演发布者的角色，而组件充当订阅和取消订阅中介事件的订阅者。当以这种方式实现Mediator时，它可能看起来非常类似于Observer。
- 当您感到困惑时，请记住您可以用其他方式实现中介模式。例如，您可以将所有组件永久链接到同一个中介对象。此实现不会类似于Observer，但仍然是Mediator模式的一个实例。
- 现在，想象一个所有组件都成为发布者的程序，允许彼此之间的动态连接。没有一个集中的中介对象，只有一组分布式的观察者。

### 备忘录模式（Memento）

- 允许您保存和恢复对象的前一个状态，而无需透露其实现的细节
- Memento模式将状态快照的创建委托给状态的实际所有者，即originator对象。因此，与其他对象试图从外部复制编辑器状态不同，编辑器类本身可以创建快照，因为它对自己的状态有完全的访问权限。
- 该模式建议将对象状态的副本存储在一个叫做memento的特殊对象中。memento的内容除了制造它的那个人以外，其他任何东西都无法接触到。其他对象必须使用一个有限的接口与mementos通信，该接口允许获取快照的元数据(创建时间，执行操作的名称等)，但不能获取快照中包含的原始对象的状态
- 基于嵌套类的实现（好处：容易保持安全性）

![](img\屏幕截图 2021-01-09 011738.png)

- 基于中间接口的实现

![](img\屏幕截图 2021-01-09 012036.png)

- 使用更严格的封装实现

![](img\屏幕截图 2021-01-09 012237.png)

#### Pros:

- 您可以在不违反对象封装的情况下生成对象状态的快照。
- 通过让管理员维护始发人状态的历史，你可以简化始发人的代码

#### Cons:

- 如果客户端过于频繁地创建Memento，该应用程序可能会消耗大量内存。
- 看护人应该追踪发起人的生命周期以摧毁过时的Mementos。
- 大多数动态编程语言,例如PHP, Python和JavaScript，不能保证备忘录内的状态保持不变

#### 与其他Patterns的关系：

- 执行“撤消”时，可以同时使用“命令”和“备忘录”。在这种情况下，命令负责在目标对象上执行各种操作，而备忘录则在命令执行之前保存该对象的状态
- 您可以使用Memento和Iterator来捕获当前的迭代状态，并在必要时回滚它
- 有时候原型可以是备忘录更简单的替代品。如果对象(您想要将其状态存储在历史记录中)相当简单且没有指向外部资源的链接，或者这些链接很容易重新建立，那么这种方法就可以工作

### 观察者模式（Observer）

- 允许您定义订阅机制来通知多个对象它们正在观察的对象发生的任何事件
- 观察者模式建议向发布者类添加订阅机制，以便单个对象可以订阅或取消订阅来自该发布者的事件流。
- 每当一个重要的事件发生在发布者身上时，它就会遍历其订阅者并在其对象上调用特定的通知方法。

![](img\屏幕截图 2021-01-09 013855.png)

#### Pros：

- 打开/关闭原则。您可以引入新的订阅者类，而不必更改发布者代码(如果有发布者接口，则反之亦然)。
- 你可以在运行时建立对象之间的关系

#### 与其他Patterns的关系：

- 同Mediator

### 状态模式（State）

- 允许对象在其内部状态改变时改变其行为。看起来好像对象改变了它的类
- State模式建议为对象的所有可能状态创建新类，并将所有特定于状态的行为提取到这些类中
- 原始对象(称为上下文)不是自己实现所有行为，而是存储对一个表示其当前状态的状态对象的引用，并将所有与状态相关的工作委托给该对象
- 要将上下文转换为另一种状态，请用表示该新状态的另一个对象替换活动状态对象。只有当所有状态类都遵循相同的接口，并且上下文本身通过该接口与这些对象一起工作时，这才可能实现
- 这种结构可能看起来与战略模式相似，但有一个关键的区别。在状态模式中，特定的状态可能知道彼此，并启动从一个状态到另一个状态的转换，而策略几乎从不知道彼此

![](img\屏幕截图 2021-01-09 015004.png)

#### Pros：

- 单一责任原则。将与特定状态相关的代码组织到单独的类中。
- 开放/封闭原则。在不改变现有状态类或上下文的情况下引入新的状态。
- 通过消除大量的状态机条件语句来简化上下文代码

#### Cons：

- 如果一个状态机只有很少的状态或很少更改，那么应用这个模式就有点过头了。

#### 与其他Patterns的关系：

- Bridge、状态、策略(以及某种程度上的适配器)具有非常相似的结构。实际上，所有这些模式都是基于组合的，即将工作委托给其他对象。然而，它们都解决不同的问题。模式不只是以特定方式构造代码的诀窍。它还可以将模式解决的问题传达给其他开发人员
- state可以看作是strategy的延伸。这两种模式都基于组合:它们通过将一些工作委托给helper对象来更改上下文的行为。**策略使这些对象完全独立，不知道彼此**。然而，状态并不限制具体状态之间的依赖关系，而是允许它们随意改变上下文的状态

### 策略模式（Strategy）

允许您定义一系列算法，将它们每个放入单独的类中，并使它们的对象可互换

![](img\屏幕截图 2021-01-09 015847.png)

#### Pros：

- 您可以在运行时交换对象内部使用的算法。
- 你可以把算法的实现细节从使用它的代码中分离出来。
- 你可以用组成代替继承。
- 开放/封闭原则。您可以引入新的策略，而不必改变环境。

#### Cons：

- 如果您只有几个算法，而且它们很少变化，那么就没有真正的理由使用该模式使程序过度复杂化。
- 客户必须了解不同策略之间的差异，以便能够选择一个合适的策略。
- 许多现代编程语言都有函数类型支持，允许您在一组匿名函数中实现算法的不同版本。然后您就可以像使用策略对象那样使用这些函数，而不用使用额外的类和接口来增加代码

#### 与其他Patterns的关系：

- 命令和策略看起来可能很相似，因为您可以使用它们来用一些操作参数化对象。然而，它们的目的却截然不同。
- 您可以使用Command将任何操作转换为对象。操作参数成为该对象的字段。这种转换允许您延迟操作的执行、将其排队、存储命令的历史记录、将命令发送到远程服务，等等。
- 另一方面，策略通常描述做同一件事的不同方法，允许您在单个上下文类中交换这些算法。
- Decorator允许您更改对象的外观，而Strategy允许您更改对象的内部结构。
- 模板方法基于继承:它允许您通过在子类中扩展算法的某些部分来更改算法的某些部分。策略是基于组合的:您可以通过为对象提供与该行为对应的不同策略来改变对象的部分行为。模板方法工作在类级别，所以它是静态的。策略在对象级别上工作，允许您在运行时切换行为。
- 状态可以看作是战略的延伸。这两种模式都基于组合:它们通过将一些工作委托给helper对象来更改上下文的行为。策略使这些对象完全独立，不知道彼此。然而，状态并不限制具体状态之间的依赖关系，而是允许它们随意改变上下文的状态。

### 模板方法模式

- 在父类中定义算法的框架，但让子类覆盖算法的特定步骤而不改变其结构
- 模板方法模式建议您将算法分解为一系列步骤，将这些步骤转换为方法，并在单个模板方法中对这些方法进行一系列调用。这些步骤可以是抽象的，也可以有一些默认的实现。要使用该算法，客户端应该提供自己的子类，实现所有抽象步骤，并在需要时覆盖一些可选的步骤(但不包括模板方法本身)。

![](img\屏幕截图 2021-01-09 021002.png)

#### Pros：

- 您可以让客户端只覆盖大型算法的某些部分，使它们不太受算法其他部分发生的更改的影响。
- 你可以把复制的代码拖到父类中

#### Cons：

- 有些客户端可能受到算法框架的限制。
- 你可能违反Liskov替换原则，通过一个子类来抑制一个默认步骤实现
- 模板方法往往难以保持更多的步骤

#### 与其他Patterns的关系：

- 工厂方法是模板方法的特化。同时，工厂方法可以作为大型模板方法中的一个步骤。
- 模板方法基于**继承**:它允许您通过在子类中扩展算法的某些部分来更改算法的某些部分。策略是基于**组合**的:您可以通过为对象提供与该行为对应的不同策略来改变对象的部分行为。模板方法工作在类级别，所以它是静态的。策略在对象级别上工作，允许您在运行时切换行为。

### 访问者模式

- 可以让你将算法与它们所操作的对象分离开来
- Visitor模式建议将新行为放入名为Visitor的单独类中，而不是尝试将其集成到现有类中。必须执行该行为的原始对象现在作为参数传递给一个访问者方法，提供对对象中包含的所有必要数据的方法访问
- 访问者模式使用了一种称为**双重分派**（Double Dispatch）的技术，这有助于在对象上执行适当的方法，而不需要麻烦的条件。与其让客户端选择要调用的方法的合适版本，不如把这个选择委托给要作为参数传递给访问者的对象。因为对象知道它们自己的类，所以它们可以在访问者上选择合适的方法，不会太尴尬。他们接受一个访问者，并告诉它应该执行什么访问方法

![](img\屏幕截图 2021-01-09 022250.png)

#### Pros:

- 打开/关闭原则。您可以引入一个新的行为，它可以在不改变这些类的情况下处理不同类的对象。
- 单一责任原则。您可以将同一行为的多个版本移动到同一个类中。
- 在使用各种对象时，visitor对象可以积累一些有用的信息。当您想要遍历某些复杂的对象结构(如对象树)并将visitor应用于该结构的每个对象时，这可能很方便。

#### Cons:

- 每次向元素层次结构中添加或删除类时，都需要更新所有访问者。
- 访问者可能缺乏必要的访问元素的私有字段和方法,他们应该一起工作

#### 与其他Patterns的关系：

- 您可以将Visitor视为命令模式的强大版本。它的对象可以在不同类的不同对象上执行操作。
- 您可以使用Visitor在整个组合树上执行操作。
- 您可以使用Visitor和Iterator来遍历复杂的数据结构，并对其元素执行一些操作，即使它们都有不同的类

### Design Pattern Relationship

![](img\屏幕截图 2021-01-09 023056.png)